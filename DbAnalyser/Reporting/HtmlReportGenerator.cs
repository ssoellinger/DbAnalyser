using System.Text;
using System.Text.Json;
using System.Web;
using DbAnalyser.Analyzers;
using DbAnalyser.Models.Quality;
using DbAnalyser.Models.Relationships;

namespace DbAnalyser.Reporting;

public class HtmlReportGenerator : IReportGenerator
{
    public OutputFormat Format => OutputFormat.Html;

    public async Task GenerateAsync(AnalysisResult result, string? outputPath, CancellationToken ct = default)
    {
        var path = outputPath ?? $"DbAnalysis_{result.DatabaseName}_{result.AnalyzedAt:yyyyMMdd_HHmmss}.html";
        var html = BuildHtml(result);
        await File.WriteAllTextAsync(path, html, ct);
        Console.WriteLine($"HTML report written to: {path}");
    }

    private string BuildHtml(AnalysisResult result)
    {
        var sb = new StringBuilder();
        sb.AppendLine("<!DOCTYPE html>");
        sb.AppendLine("<html lang=\"en\">");
        sb.AppendLine("<head>");
        sb.AppendLine("<meta charset=\"UTF-8\">");
        sb.AppendLine("<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">");
        sb.AppendLine($"<title>Database Analysis - {E(result.DatabaseName)}</title>");
        sb.AppendLine("<style>");
        sb.AppendLine(GetCss());
        sb.AppendLine("</style>");
        sb.AppendLine("</head>");
        sb.AppendLine("<body>");
        sb.AppendLine($"<header><h1>Database Analysis: {E(result.DatabaseName)}</h1>");
        sb.AppendLine($"<p class=\"meta\">Analyzed at {result.AnalyzedAt:yyyy-MM-dd HH:mm:ss} UTC</p></header>");

        sb.AppendLine("<nav>");
        if (result.Relationships?.Dependencies.Count > 0) sb.AppendLine("<a href=\"#dependencies\">Dependencies</a>");
        if (result.Schema is not null) sb.AppendLine("<a href=\"#schema\">Schema</a>");
        if (result.Profiles is not null) sb.AppendLine("<a href=\"#profiling\">Profiling</a>");
        if (result.Relationships is not null) sb.AppendLine("<a href=\"#relationships\">Relationships</a>");
        if (result.QualityIssues is not null) sb.AppendLine("<a href=\"#quality\">Quality</a>");
        sb.AppendLine("</nav>");

        sb.AppendLine("<main>");

        if (result.Relationships?.Dependencies.Count > 0)
            BuildDependencySection(sb, result);

        if (result.Schema is not null)
            BuildSchemaSection(sb, result);

        if (result.Profiles is not null)
            BuildProfilingSection(sb, result);

        if (result.Relationships is not null)
            BuildRelationshipsSection(sb, result);

        if (result.QualityIssues is not null)
            BuildQualitySection(sb, result);

        sb.AppendLine("</main>");
        sb.AppendLine("<footer><p>Generated by DbAnalyser</p></footer>");

        if (result.Relationships?.Dependencies.Count > 0)
        {
            sb.AppendLine("<script>");
            sb.AppendLine(GetGraphJs(result));
            sb.AppendLine("</script>");
        }

        sb.AppendLine("</body></html>");

        return sb.ToString();
    }

    private void BuildDependencySection(StringBuilder sb, AnalysisResult result)
    {
        var deps = result.Relationships!.Dependencies;
        var connected = deps.Where(d => d.DirectConnections > 0).ToList();
        var orphaned = deps.Where(d => d.DirectConnections == 0).ToList();

        sb.AppendLine("<section id=\"dependencies\">");
        sb.AppendLine("<h2>Dependency Overview</h2>");

        // Summary cards
        sb.AppendLine("<div class=\"summary-grid\">");
        sb.AppendLine($"<div class=\"card\"><h3>{deps.Count}</h3><p>Total Tables</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{connected.Count}</h3><p>Connected</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{orphaned.Count}</h3><p>Standalone</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{result.Relationships!.ExplicitRelationships.Count}</h3><p>Foreign Keys</p></div>");
        sb.AppendLine("</div>");

        // Interactive graph
        sb.AppendLine("<h3>Relationship Graph</h3>");
        sb.AppendLine("<p class=\"meta\">Drag nodes to rearrange. Hover for details. Scroll to zoom. Node size = importance.</p>");
        sb.AppendLine("<div id=\"graph-container\"><svg id=\"dep-graph\"></svg></div>");

        // Dependency ranking table
        if (connected.Count > 0)
        {
            sb.AppendLine("<h3>Table Importance Ranking</h3>");
            sb.AppendLine("<p class=\"meta\">Tables ranked by how central they are. \"Referenced By\" = other tables depend on this one. \"Impact\" = total tables transitively affected.</p>");
            sb.AppendLine("<table><thead><tr><th>Rank</th><th>Table</th><th>Referenced By</th><th>Depends On</th><th>Transitive Impact</th><th>Score</th></tr></thead><tbody>");

            var rank = 1;
            foreach (var dep in connected.OrderByDescending(d => d.ImportanceScore))
            {
                var impactClass = dep.TransitiveImpact.Count > 10 ? "error" : dep.TransitiveImpact.Count > 5 ? "warn" : "";
                sb.AppendLine($"<tr><td>{rank++}</td><td><strong>{E(dep.FullName)}</strong></td>");
                sb.AppendLine($"<td>{dep.ReferencedBy.Count}</td>");
                sb.AppendLine($"<td>{dep.DependsOn.Count}</td>");
                sb.AppendLine($"<td class=\"{impactClass}\">{dep.TransitiveImpact.Count}</td>");
                sb.AppendLine($"<td>{dep.ImportanceScore}</td></tr>");
            }
            sb.AppendLine("</tbody></table>");

            // Impact details (expandable per core table)
            var coreTables = connected
                .Where(d => d.ReferencedBy.Count > 0)
                .OrderByDescending(d => d.TransitiveImpact.Count)
                .ToList();

            if (coreTables.Count > 0)
            {
                sb.AppendLine("<h3>Impact Analysis</h3>");
                sb.AppendLine("<p class=\"meta\">If you modify a core table, these tables are affected (directly or transitively).</p>");

                foreach (var dep in coreTables)
                {
                    sb.AppendLine($"<details><summary><strong>{E(dep.FullName)}</strong> — {dep.ReferencedBy.Count} direct, {dep.TransitiveImpact.Count} total impact</summary>");
                    sb.AppendLine("<div class=\"impact-detail\">");

                    sb.AppendLine("<div class=\"impact-col\"><h4>Direct dependents</h4><ul>");
                    foreach (var t in dep.ReferencedBy.Order())
                        sb.AppendLine($"<li>{E(t)}</li>");
                    sb.AppendLine("</ul></div>");

                    if (dep.TransitiveImpact.Count > dep.ReferencedBy.Count)
                    {
                        var indirect = dep.TransitiveImpact.Except(dep.ReferencedBy, StringComparer.OrdinalIgnoreCase).Order();
                        sb.AppendLine("<div class=\"impact-col\"><h4>Indirect (transitive)</h4><ul>");
                        foreach (var t in indirect)
                            sb.AppendLine($"<li class=\"meta\">{E(t)}</li>");
                        sb.AppendLine("</ul></div>");
                    }

                    sb.AppendLine("<div class=\"impact-col\"><h4>This table depends on</h4><ul>");
                    foreach (var t in dep.DependsOn.Order())
                        sb.AppendLine($"<li>{E(t)}</li>");
                    if (dep.DependsOn.Count == 0)
                        sb.AppendLine("<li class=\"meta\">None (root table)</li>");
                    sb.AppendLine("</ul></div>");

                    sb.AppendLine("</div></details>");
                }
            }
        }

        // Orphaned tables
        if (orphaned.Count > 0)
        {
            sb.AppendLine("<details><summary><h3 style=\"display:inline\">Standalone Tables</h3> <span class=\"meta\">(" + orphaned.Count + " tables with no FK relationships)</span></summary><ul>");
            foreach (var dep in orphaned.OrderBy(d => d.FullName))
                sb.AppendLine($"<li>{E(dep.FullName)}</li>");
            sb.AppendLine("</ul></details>");
        }

        sb.AppendLine("</section>");
    }

    private void BuildSchemaSection(StringBuilder sb, AnalysisResult result)
    {
        var schema = result.Schema!;
        sb.AppendLine("<section id=\"schema\">");
        sb.AppendLine("<h2>Schema Overview</h2>");

        sb.AppendLine("<div class=\"summary-grid\">");
        sb.AppendLine($"<div class=\"card\"><h3>{schema.Tables.Count}</h3><p>Tables</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{schema.Views.Count}</h3><p>Views</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{schema.StoredProcedures.Count}</h3><p>Stored Procedures</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{schema.Tables.Sum(t => t.Columns.Count)}</h3><p>Total Columns</p></div>");
        sb.AppendLine("</div>");

        foreach (var table in schema.Tables)
        {
            sb.AppendLine($"<h3 id=\"table-{E(table.FullName)}\">{E(table.FullName)}</h3>");
            sb.AppendLine("<table><thead><tr><th>Column</th><th>Type</th><th>Nullable</th><th>PK</th><th>Identity</th><th>Default</th></tr></thead><tbody>");

            foreach (var col in table.Columns)
            {
                var typeStr = col.MaxLength.HasValue
                    ? $"{col.DataType}({(col.MaxLength == -1 ? "MAX" : col.MaxLength.ToString())})"
                    : col.Precision.HasValue
                        ? $"{col.DataType}({col.Precision},{col.Scale})"
                        : col.DataType;

                sb.AppendLine($"<tr><td>{E(col.Name)}</td><td>{typeStr}</td>");
                sb.AppendLine($"<td>{(col.IsNullable ? "<span class=\"warn\">YES</span>" : "NO")}</td>");
                sb.AppendLine($"<td>{(col.IsPrimaryKey ? "<span class=\"ok\">PK</span>" : "")}</td>");
                sb.AppendLine($"<td>{(col.IsIdentity ? "Yes" : "")}</td>");
                sb.AppendLine($"<td>{E(col.DefaultValue ?? "")}</td></tr>");
            }

            sb.AppendLine("</tbody></table>");

            if (table.Indexes.Count > 0)
            {
                sb.AppendLine("<details><summary>Indexes</summary>");
                sb.AppendLine("<table><thead><tr><th>Name</th><th>Type</th><th>Unique</th><th>Columns</th></tr></thead><tbody>");
                foreach (var idx in table.Indexes)
                {
                    sb.AppendLine($"<tr><td>{E(idx.Name)}</td><td>{idx.Type}</td><td>{(idx.IsUnique ? "Yes" : "No")}</td><td>{E(string.Join(", ", idx.Columns))}</td></tr>");
                }
                sb.AppendLine("</tbody></table></details>");
            }
        }

        sb.AppendLine("</section>");
    }

    private void BuildProfilingSection(StringBuilder sb, AnalysisResult result)
    {
        sb.AppendLine("<section id=\"profiling\">");
        sb.AppendLine("<h2>Data Profiling</h2>");

        foreach (var profile in result.Profiles!)
        {
            sb.AppendLine($"<h3>{E(profile.FullName)} <span class=\"meta\">({profile.RowCount:N0} rows)</span></h3>");

            if (profile.RowCount == 0)
            {
                sb.AppendLine("<p class=\"meta\">Empty table</p>");
                continue;
            }

            sb.AppendLine("<table><thead><tr><th>Column</th><th>Type</th><th>Null %</th><th>Distinct</th><th>Min</th><th>Max</th></tr></thead><tbody>");

            foreach (var col in profile.ColumnProfiles)
            {
                var nullClass = col.NullPercentage > 50 ? "error" : col.NullPercentage > 0 ? "warn" : "ok";
                sb.AppendLine($"<tr><td>{E(col.ColumnName)}</td><td>{col.DataType}</td>");
                sb.AppendLine($"<td class=\"{nullClass}\">{col.NullPercentage:F1}%</td>");
                sb.AppendLine($"<td>{col.DistinctCount:N0}</td>");
                sb.AppendLine($"<td>{E(Truncate(col.MinValue, 40))}</td>");
                sb.AppendLine($"<td>{E(Truncate(col.MaxValue, 40))}</td></tr>");
            }

            sb.AppendLine("</tbody></table>");
        }

        sb.AppendLine("</section>");
    }

    private void BuildRelationshipsSection(StringBuilder sb, AnalysisResult result)
    {
        var map = result.Relationships!;
        sb.AppendLine("<section id=\"relationships\">");
        sb.AppendLine("<h2>Relationships Detail</h2>");

        if (map.ExplicitRelationships.Count > 0)
        {
            sb.AppendLine("<h3>Explicit Foreign Keys</h3>");
            sb.AppendLine("<table><thead><tr><th>Name</th><th>From</th><th>To</th><th>Delete</th><th>Update</th></tr></thead><tbody>");
            foreach (var fk in map.ExplicitRelationships)
            {
                sb.AppendLine($"<tr><td>{E(fk.Name)}</td>");
                sb.AppendLine($"<td>{E(fk.FromSchema)}.{E(fk.FromTable)}.{E(fk.FromColumn)}</td>");
                sb.AppendLine($"<td>{E(fk.ToSchema)}.{E(fk.ToTable)}.{E(fk.ToColumn)}</td>");
                sb.AppendLine($"<td>{fk.DeleteRule}</td><td>{fk.UpdateRule}</td></tr>");
            }
            sb.AppendLine("</tbody></table>");
        }

        if (map.ImplicitRelationships.Count > 0)
        {
            sb.AppendLine("<h3>Implicit (Detected) Relationships</h3>");
            sb.AppendLine("<table><thead><tr><th>From</th><th>To</th><th>Confidence</th><th>Reason</th></tr></thead><tbody>");
            foreach (var rel in map.ImplicitRelationships)
            {
                sb.AppendLine($"<tr><td>{E(rel.FromSchema)}.{E(rel.FromTable)}.{E(rel.FromColumn)}</td>");
                sb.AppendLine($"<td>{E(rel.ToSchema)}.{E(rel.ToTable)}.{E(rel.ToColumn)}</td>");
                sb.AppendLine($"<td>{rel.Confidence:P0}</td><td>{E(rel.Reason)}</td></tr>");
            }
            sb.AppendLine("</tbody></table>");
        }

        sb.AppendLine("</section>");
    }

    private void BuildQualitySection(StringBuilder sb, AnalysisResult result)
    {
        var issues = result.QualityIssues!;
        sb.AppendLine("<section id=\"quality\">");
        sb.AppendLine("<h2>Quality Issues</h2>");

        if (issues.Count == 0)
        {
            sb.AppendLine("<p class=\"ok\">No quality issues found.</p>");
            sb.AppendLine("</section>");
            return;
        }

        var grouped = issues.GroupBy(i => i.Severity).OrderByDescending(g => g.Key);
        foreach (var group in grouped)
        {
            var cssClass = group.Key switch
            {
                IssueSeverity.Error => "error",
                IssueSeverity.Warning => "warn",
                _ => "info"
            };

            sb.AppendLine($"<h3 class=\"{cssClass}\">{group.Key} ({group.Count()})</h3>");
            sb.AppendLine("<table><thead><tr><th>Object</th><th>Category</th><th>Issue</th><th>Recommendation</th></tr></thead><tbody>");
            foreach (var issue in group)
            {
                sb.AppendLine($"<tr><td>{E(issue.ObjectName)}</td><td>{issue.Category}</td>");
                sb.AppendLine($"<td>{E(issue.Description)}</td><td>{E(issue.Recommendation ?? "")}</td></tr>");
            }
            sb.AppendLine("</tbody></table>");
        }

        sb.AppendLine("</section>");
    }

    private static string E(string text) => HttpUtility.HtmlEncode(text);

    private static string Truncate(string? value, int maxLength)
    {
        if (string.IsNullOrEmpty(value)) return "";
        return value.Length <= maxLength ? value : value[..maxLength] + "...";
    }

    private string GetGraphJs(AnalysisResult result)
    {
        var deps = result.Relationships!.Dependencies;
        var fks = result.Relationships!.ExplicitRelationships;

        // Build nodes array
        var connected = deps.Where(d => d.DirectConnections > 0).ToList();
        var nodeIndex = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
        var nodes = new List<object>();
        for (var i = 0; i < connected.Count; i++)
        {
            var d = connected[i];
            nodeIndex[d.FullName] = i;
            nodes.Add(new
            {
                id = d.FullName,
                label = d.TableName,
                refBy = d.ReferencedBy.Count,
                depOn = d.DependsOn.Count,
                impact = d.TransitiveImpact.Count,
                score = d.ImportanceScore
            });
        }

        // Build edges (deduplicated at table level)
        var edgeSet = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        var edges = new List<object>();
        foreach (var fk in fks)
        {
            var from = $"{fk.FromSchema}.{fk.FromTable}";
            var to = $"{fk.ToSchema}.{fk.ToTable}";
            var key = $"{from}->{to}";
            if (!edgeSet.Add(key)) continue;
            if (!nodeIndex.ContainsKey(from) || !nodeIndex.ContainsKey(to)) continue;
            edges.Add(new { source = nodeIndex[from], target = nodeIndex[to] });
        }

        var nodesJson = JsonSerializer.Serialize(nodes);
        var edgesJson = JsonSerializer.Serialize(edges);

        return $$"""
const graphNodes = {{nodesJson}};
const graphEdges = {{edgesJson}};

(function() {
    const svg = document.getElementById('dep-graph');
    const container = document.getElementById('graph-container');
    const width = container.clientWidth || 1200;
    const height = Math.max(600, Math.min(graphNodes.length * 12, 1000));
    svg.setAttribute('width', width);
    svg.setAttribute('height', height);
    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

    const maxScore = Math.max(...graphNodes.map(n => n.score), 1);

    // Initialize positions in a circle
    graphNodes.forEach((n, i) => {
        const angle = (2 * Math.PI * i) / graphNodes.length;
        const r = Math.min(width, height) * 0.35;
        n.x = width / 2 + r * Math.cos(angle);
        n.y = height / 2 + r * Math.sin(angle);
        n.vx = 0;
        n.vy = 0;
        n.radius = 6 + (n.score / maxScore) * 20;
    });

    // SVG groups
    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
    marker.setAttribute('id', 'arrow');
    marker.setAttribute('viewBox', '0 0 10 10');
    marker.setAttribute('refX', '10');
    marker.setAttribute('refY', '5');
    marker.setAttribute('markerWidth', '6');
    marker.setAttribute('markerHeight', '6');
    marker.setAttribute('orient', 'auto-start-reverse');
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
    path.setAttribute('fill', '#4fc3f7');
    marker.appendChild(path);
    defs.appendChild(marker);
    svg.appendChild(defs);

    const edgeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const nodeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const labelGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    svg.appendChild(edgeGroup);
    svg.appendChild(nodeGroup);
    svg.appendChild(labelGroup);

    // Tooltip
    const tooltip = document.createElement('div');
    tooltip.className = 'graph-tooltip';
    container.appendChild(tooltip);

    // Create edge elements
    const edgeEls = graphEdges.map(e => {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('stroke', '#4fc3f7');
        line.setAttribute('stroke-opacity', '0.4');
        line.setAttribute('stroke-width', '1.5');
        line.setAttribute('marker-end', 'url(#arrow)');
        edgeGroup.appendChild(line);
        return line;
    });

    // Create node elements
    const nodeEls = graphNodes.map((n, i) => {
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('r', n.radius);
        const hue = n.refBy > 0 ? (n.refBy > 5 ? 0 : 30) : 200;
        const sat = 70;
        const light = 50 + (n.score / maxScore) * 20;
        circle.setAttribute('fill', `hsl(${hue}, ${sat}%, ${light}%)`);
        circle.setAttribute('stroke', '#e0e0e0');
        circle.setAttribute('stroke-width', '1');
        circle.setAttribute('cursor', 'grab');

        circle.addEventListener('mouseenter', (ev) => {
            tooltip.innerHTML = `<strong>${n.id}</strong><br>Referenced by: ${n.refBy}<br>Depends on: ${n.depOn}<br>Impact: ${n.impact}<br>Score: ${n.score}`;
            tooltip.style.display = 'block';
            tooltip.style.left = (ev.offsetX + 15) + 'px';
            tooltip.style.top = (ev.offsetY - 10) + 'px';
            // Highlight connected edges
            graphEdges.forEach((e, ei) => {
                if (e.source === i || e.target === i) {
                    edgeEls[ei].setAttribute('stroke-opacity', '1');
                    edgeEls[ei].setAttribute('stroke-width', '2.5');
                }
            });
            circle.setAttribute('stroke-width', '3');
        });

        circle.addEventListener('mouseleave', () => {
            tooltip.style.display = 'none';
            graphEdges.forEach((e, ei) => {
                edgeEls[ei].setAttribute('stroke-opacity', '0.4');
                edgeEls[ei].setAttribute('stroke-width', '1.5');
            });
            circle.setAttribute('stroke-width', '1');
        });

        nodeGroup.appendChild(circle);
        return circle;
    });

    // Create labels
    const labelEls = graphNodes.map(n => {
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.textContent = n.label;
        text.setAttribute('font-size', Math.max(9, Math.min(13, 8 + n.radius / 4)));
        text.setAttribute('fill', '#e0e0e0');
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('pointer-events', 'none');
        labelGroup.appendChild(text);
        return text;
    });

    // Drag
    let dragNode = null, dragOffset = {x:0,y:0};
    svg.addEventListener('mousedown', (ev) => {
        const rect = svg.getBoundingClientRect();
        const mx = ev.clientX - rect.left, my = ev.clientY - rect.top;
        for (let i = 0; i < graphNodes.length; i++) {
            const n = graphNodes[i];
            if (Math.hypot(mx - n.x, my - n.y) < n.radius + 5) {
                dragNode = i;
                dragOffset = { x: mx - n.x, y: my - n.y };
                graphNodes[i].fx = n.x;
                graphNodes[i].fy = n.y;
                svg.style.cursor = 'grabbing';
                break;
            }
        }
    });
    svg.addEventListener('mousemove', (ev) => {
        if (dragNode === null) return;
        const rect = svg.getBoundingClientRect();
        graphNodes[dragNode].fx = ev.clientX - rect.left - dragOffset.x;
        graphNodes[dragNode].fy = ev.clientY - rect.top - dragOffset.y;
    });
    svg.addEventListener('mouseup', () => {
        if (dragNode !== null) {
            graphNodes[dragNode].x = graphNodes[dragNode].fx;
            graphNodes[dragNode].y = graphNodes[dragNode].fy;
            delete graphNodes[dragNode].fx;
            delete graphNodes[dragNode].fy;
        }
        dragNode = null;
        svg.style.cursor = 'default';
    });

    // Force simulation
    function tick() {
        const N = graphNodes.length;
        // Repulsion (all pairs)
        for (let i = 0; i < N; i++) {
            for (let j = i + 1; j < N; j++) {
                let dx = graphNodes[i].x - graphNodes[j].x;
                let dy = graphNodes[i].y - graphNodes[j].y;
                let dist = Math.sqrt(dx*dx + dy*dy) || 1;
                let force = 800 / (dist * dist);
                let fx = dx / dist * force;
                let fy = dy / dist * force;
                graphNodes[i].vx += fx;
                graphNodes[i].vy += fy;
                graphNodes[j].vx -= fx;
                graphNodes[j].vy -= fy;
            }
        }
        // Attraction (edges)
        graphEdges.forEach(e => {
            let s = graphNodes[e.source], t = graphNodes[e.target];
            let dx = t.x - s.x, dy = t.y - s.y;
            let dist = Math.sqrt(dx*dx + dy*dy) || 1;
            let force = (dist - 120) * 0.005;
            let fx = dx / dist * force;
            let fy = dy / dist * force;
            s.vx += fx; s.vy += fy;
            t.vx -= fx; t.vy -= fy;
        });
        // Center gravity
        graphNodes.forEach(n => {
            n.vx += (width/2 - n.x) * 0.001;
            n.vy += (height/2 - n.y) * 0.001;
        });
        // Apply velocity
        graphNodes.forEach((n, i) => {
            if (i === dragNode) {
                n.x = n.fx; n.y = n.fy;
                n.vx = 0; n.vy = 0;
                return;
            }
            n.vx *= 0.85;
            n.vy *= 0.85;
            n.x += n.vx;
            n.y += n.vy;
            n.x = Math.max(n.radius, Math.min(width - n.radius, n.x));
            n.y = Math.max(n.radius, Math.min(height - n.radius, n.y));
        });
        // Update SVG
        graphEdges.forEach((e, i) => {
            let s = graphNodes[e.source], t = graphNodes[e.target];
            let dx = t.x - s.x, dy = t.y - s.y;
            let dist = Math.sqrt(dx*dx + dy*dy) || 1;
            let offsetS = s.radius / dist, offsetT = t.radius / dist;
            edgeEls[i].setAttribute('x1', s.x + dx * offsetS);
            edgeEls[i].setAttribute('y1', s.y + dy * offsetS);
            edgeEls[i].setAttribute('x2', t.x - dx * offsetT);
            edgeEls[i].setAttribute('y2', t.y - dy * offsetT);
        });
        nodeEls.forEach((el, i) => {
            el.setAttribute('cx', graphNodes[i].x);
            el.setAttribute('cy', graphNodes[i].y);
        });
        labelEls.forEach((el, i) => {
            el.setAttribute('x', graphNodes[i].x);
            el.setAttribute('y', graphNodes[i].y + graphNodes[i].radius + 14);
        });
        requestAnimationFrame(tick);
    }
    tick();
})();
""";
    }

    private static string GetCss() => """
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #1a1a2e; color: #e0e0e0; line-height: 1.6; }
        header { background: #16213e; padding: 2rem; border-bottom: 3px solid #0f3460; }
        h1 { color: #e94560; }
        h2 { color: #0f3460; background: #16213e; padding: 0.8rem 1rem; margin: 1.5rem 0 1rem; border-left: 4px solid #e94560; }
        h3 { color: #e94560; margin: 1rem 0 0.5rem; }
        h4 { color: #4fc3f7; margin: 0.5rem 0 0.3rem; }
        nav { background: #16213e; padding: 0.5rem 1rem; display: flex; gap: 1rem; border-bottom: 1px solid #0f3460; position: sticky; top: 0; z-index: 100; }
        nav a { color: #e94560; text-decoration: none; padding: 0.3rem 0.8rem; border-radius: 4px; }
        nav a:hover { background: #0f3460; }
        main { max-width: 1400px; margin: 0 auto; padding: 1rem 2rem; }
        table { width: 100%; border-collapse: collapse; margin: 0.5rem 0 1rem; background: #16213e; border-radius: 4px; overflow: hidden; }
        th { background: #0f3460; color: #e0e0e0; text-align: left; padding: 0.6rem 0.8rem; font-weight: 600; }
        td { padding: 0.4rem 0.8rem; border-bottom: 1px solid #1a1a2e; }
        tr:hover td { background: #1a1a3e; }
        .meta { color: #888; font-size: 0.9em; }
        .ok { color: #4ecca3; }
        .warn { color: #f0a500; }
        .error { color: #e94560; }
        .info { color: #4fc3f7; }
        .summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem; margin: 1rem 0; }
        .card { background: #16213e; padding: 1.2rem; border-radius: 8px; text-align: center; border: 1px solid #0f3460; }
        .card h3 { color: #4ecca3; font-size: 2em; margin: 0; }
        .card p { color: #888; margin: 0.3rem 0 0; }
        details { margin: 0.5rem 0; }
        summary { cursor: pointer; color: #4fc3f7; padding: 0.3rem 0; }
        footer { text-align: center; padding: 2rem; color: #555; border-top: 1px solid #0f3460; margin-top: 2rem; }
        #graph-container { position: relative; background: #0d0d1a; border: 1px solid #0f3460; border-radius: 8px; margin: 1rem 0; overflow: hidden; }
        #dep-graph { display: block; }
        .graph-tooltip { display: none; position: absolute; background: #16213e; border: 1px solid #0f3460; padding: 0.6rem 0.8rem; border-radius: 6px; font-size: 0.85em; pointer-events: none; z-index: 10; color: #e0e0e0; box-shadow: 0 4px 12px rgba(0,0,0,0.5); }
        .impact-detail { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; padding: 0.8rem; background: #0d0d1a; border-radius: 6px; margin: 0.5rem 0; }
        .impact-detail ul { list-style: none; padding-left: 0.5rem; }
        .impact-detail li { padding: 0.15rem 0; }
        .impact-detail li::before { content: "→ "; color: #4fc3f7; }
        """;
}
