using System.Text;
using System.Text.Json;
using System.Web;
using DbAnalyser.Analyzers;
using DbAnalyser.Models.Quality;
using DbAnalyser.Models.Relationships;
using DbAnalyser.Models.Schema;

namespace DbAnalyser.Reporting;

public class HtmlReportGenerator : IReportGenerator
{
    public OutputFormat Format => OutputFormat.Html;

    public async Task GenerateAsync(AnalysisResult result, string? outputPath, CancellationToken ct = default)
    {
        var path = outputPath ?? $"DbAnalysis_{result.DatabaseName}_{result.AnalyzedAt:yyyyMMdd_HHmmss}.html";
        var html = BuildHtml(result);
        await File.WriteAllTextAsync(path, html, ct);
        Console.WriteLine($"HTML report written to: {path}");
    }

    private string BuildHtml(AnalysisResult result)
    {
        var sb = new StringBuilder();
        sb.AppendLine("<!DOCTYPE html>");
        sb.AppendLine("<html lang=\"en\">");
        sb.AppendLine("<head>");
        sb.AppendLine("<meta charset=\"UTF-8\">");
        sb.AppendLine("<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">");
        sb.AppendLine($"<title>Database Analysis - {E(result.DatabaseName)}</title>");
        sb.AppendLine("<style>");
        sb.AppendLine(GetCss());
        sb.AppendLine("</style>");
        sb.AppendLine("</head>");
        sb.AppendLine("<body>");
        sb.AppendLine($"<header><h1>Database Analysis: {E(result.DatabaseName)}</h1>");
        sb.AppendLine($"<p class=\"meta\">Analyzed at {result.AnalyzedAt:yyyy-MM-dd HH:mm:ss} UTC</p></header>");

        sb.AppendLine("<nav>");
        if (result.Relationships?.Dependencies.Count > 0) sb.AppendLine("<a href=\"#dependencies\">Dependencies</a>");
        if (result.Schema?.Tables.Count > 0) sb.AppendLine("<a href=\"#erd\">ERD</a>");
        if (result.Relationships?.Dependencies.Count > 0) sb.AppendLine("<a href=\"#lineage\">Data Lineage</a>");
        if (result.Schema is not null) sb.AppendLine("<a href=\"#schema\">Schema</a>");
        if (result.Profiles is not null) sb.AppendLine("<a href=\"#profiling\">Profiling</a>");
        if (result.Relationships is not null) sb.AppendLine("<a href=\"#relationships\">Relationships</a>");
        if (result.QualityIssues is not null) sb.AppendLine("<a href=\"#quality\">Quality</a>");
        sb.AppendLine("</nav>");

        sb.AppendLine("<main>");

        if (result.Relationships?.Dependencies.Count > 0)
            BuildDependencySection(sb, result);

        if (result.Schema?.Tables.Count > 0)
            BuildErdSection(sb, result);

        if (result.Relationships?.Dependencies.Count > 0)
            BuildLineageSection(sb, result);

        if (result.Schema is not null)
            BuildSchemaSection(sb, result);

        if (result.Profiles is not null)
            BuildProfilingSection(sb, result);

        if (result.Relationships is not null)
            BuildRelationshipsSection(sb, result);

        if (result.QualityIssues is not null)
            BuildQualitySection(sb, result);

        sb.AppendLine("</main>");
        sb.AppendLine("<footer><p>Generated by DbAnalyser</p></footer>");

        if (result.Relationships?.Dependencies.Count > 0)
        {
            sb.AppendLine("<script>");
            sb.AppendLine(GetGraphJs(result));
            sb.AppendLine("</script>");
        }

        if (result.Schema?.Tables.Count > 0)
        {
            sb.AppendLine("<script>");
            sb.AppendLine(GetErdJs(result));
            sb.AppendLine("</script>");
        }

        if (result.Relationships?.Dependencies.Count > 0)
        {
            sb.AppendLine("<script>");
            sb.AppendLine(GetLineageJs(result));
            sb.AppendLine("</script>");
        }

        sb.AppendLine("</body></html>");

        return sb.ToString();
    }

    private void BuildDependencySection(StringBuilder sb, AnalysisResult result)
    {
        var deps = result.Relationships!.Dependencies;
        var connected = deps.Where(d => d.DirectConnections > 0).ToList();
        var orphaned = deps.Where(d => d.DirectConnections == 0).ToList();

        sb.AppendLine("<section id=\"dependencies\">");
        sb.AppendLine("<h2>Dependency Overview</h2>");

        var tableCount = deps.Count(d => d.ObjectType == "Table");
        var viewCount = deps.Count(d => d.ObjectType == "View");
        var sprocCount = deps.Count(d => d.ObjectType == "Procedure");
        var funcCount = deps.Count(d => d.ObjectType == "Function");
        var triggerCount = deps.Count(d => d.ObjectType == "Trigger");
        var synonymCount = deps.Count(d => d.ObjectType == "Synonym");
        var externalCount = deps.Count(d => d.ObjectType == "External");
        var jobCount = deps.Count(d => d.ObjectType == "Job");
        var crossDbDeps = result.Relationships!.ViewDependencies.Where(d => d.IsCrossDatabase).ToList();

        // Summary cards
        sb.AppendLine("<div class=\"summary-grid\">");
        sb.AppendLine($"<div class=\"card\"><h3>{tableCount}</h3><p>Tables</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{viewCount}</h3><p>Views</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{sprocCount}</h3><p>Procedures</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{funcCount}</h3><p>Functions</p></div>");
        if (triggerCount > 0)
            sb.AppendLine($"<div class=\"card\"><h3>{triggerCount}</h3><p>Triggers</p></div>");
        if (synonymCount > 0)
            sb.AppendLine($"<div class=\"card\"><h3>{synonymCount}</h3><p>Synonyms</p></div>");
        if (jobCount > 0)
            sb.AppendLine($"<div class=\"card\"><h3>{jobCount}</h3><p>Jobs</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{connected.Count}</h3><p>Connected</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{orphaned.Count}</h3><p>Standalone</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{result.Relationships!.ExplicitRelationships.Count}</h3><p>Foreign Keys</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{result.Relationships!.ViewDependencies.Count}</h3><p>Object Dependencies</p></div>");
        if (externalCount > 0)
            sb.AppendLine($"<div class=\"card\"><h3>{externalCount}</h3><p>Cross-DB References</p></div>");
        sb.AppendLine("</div>");

        // Cycle warning banner (populated by JS at runtime)
        sb.AppendLine("<div id=\"cycle-warning\" style=\"display:none\"></div>");

        // Interactive graph
        sb.AppendLine("<h3>Relationship Graph</h3>");
        sb.AppendLine("<p class=\"meta\">Scroll to zoom. Drag empty space to pan. Drag nodes to rearrange. Hover for details. Node size = importance.</p>");

        // Node type filters
        sb.AppendLine("<div class=\"graph-filters\">");
        sb.AppendLine("<span class=\"meta\">Objects:</span>");
        sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#e94560\"><input type=\"checkbox\" value=\"table\" checked onchange=\"toggleNodeFilter(this)\"><span>&#9679; Tables ({tableCount})</span></label>");
        sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#4ecca3\"><input type=\"checkbox\" value=\"view\" checked onchange=\"toggleNodeFilter(this)\"><span>&#9670; Views ({viewCount})</span></label>");
        if (sprocCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#f0a500\"><input type=\"checkbox\" value=\"procedure\" checked onchange=\"toggleNodeFilter(this)\"><span>&#9632; Procedures ({sprocCount})</span></label>");
        if (funcCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#bb86fc\"><input type=\"checkbox\" value=\"function\" checked onchange=\"toggleNodeFilter(this)\"><span>&#9650; Functions ({funcCount})</span></label>");
        if (triggerCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#ff7043\"><input type=\"checkbox\" value=\"trigger\" checked onchange=\"toggleNodeFilter(this)\"><span>&#9889; Triggers ({triggerCount})</span></label>");
        if (synonymCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#78909c\"><input type=\"checkbox\" value=\"synonym\" checked onchange=\"toggleNodeFilter(this)\"><span>&#8801; Synonyms ({synonymCount})</span></label>");
        if (jobCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#26a69a\"><input type=\"checkbox\" value=\"job\" checked onchange=\"toggleNodeFilter(this)\"><span>&#9881; Jobs ({jobCount})</span></label>");
        if (externalCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#ff6b6b\"><input type=\"checkbox\" value=\"external\" checked onchange=\"toggleNodeFilter(this)\"><span>&#9674; External ({externalCount})</span></label>");
        sb.AppendLine("</div>");

        // Edge type filters
        var fkEdgeCount = result.Relationships!.ExplicitRelationships.Count;
        var viewEdgeCount = result.Relationships!.ViewDependencies.Count(d => !d.IsCrossDatabase && d.FromType == "View");
        var sprocEdgeCount = result.Relationships!.ViewDependencies.Count(d => !d.IsCrossDatabase && d.FromType == "Procedure");
        var funcEdgeCount = result.Relationships!.ViewDependencies.Count(d => !d.IsCrossDatabase && d.FromType == "Function");
        var triggerEdgeCount = result.Relationships!.ViewDependencies.Count(d => !d.IsCrossDatabase && d.FromType == "Trigger");
        var synonymEdgeCount = result.Relationships!.ViewDependencies.Count(d => !d.IsCrossDatabase && d.FromType == "Synonym");
        var jobEdgeCount = result.Relationships!.ViewDependencies.Count(d => !d.IsCrossDatabase && d.FromType == "Job");
        var extEdgeCount = result.Relationships!.ViewDependencies.Count(d => d.IsCrossDatabase);

        sb.AppendLine("<div class=\"graph-filters\">");
        sb.AppendLine("<span class=\"meta\">Relations:</span>");
        sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#4fc3f7\"><input type=\"checkbox\" value=\"fk\" checked onchange=\"toggleEdgeFilter(this)\"><span>FK: Table &harr; Table ({fkEdgeCount})</span></label>");
        if (viewEdgeCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#4ecca3\"><input type=\"checkbox\" value=\"view\" checked onchange=\"toggleEdgeFilter(this)\"><span>View &rarr; Table/View ({viewEdgeCount})</span></label>");
        if (sprocEdgeCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#f0a500\"><input type=\"checkbox\" value=\"procedure\" checked onchange=\"toggleEdgeFilter(this)\"><span>Procedure &rarr; Table/View/Func ({sprocEdgeCount})</span></label>");
        if (funcEdgeCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#bb86fc\"><input type=\"checkbox\" value=\"function\" checked onchange=\"toggleEdgeFilter(this)\"><span>Function &rarr; Table/View ({funcEdgeCount})</span></label>");
        if (triggerEdgeCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#ff7043\"><input type=\"checkbox\" value=\"trigger\" checked onchange=\"toggleEdgeFilter(this)\"><span>Trigger &rarr; Table/Proc ({triggerEdgeCount})</span></label>");
        if (synonymEdgeCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#78909c\"><input type=\"checkbox\" value=\"synonym\" checked onchange=\"toggleEdgeFilter(this)\"><span>Synonym &rarr; Table/View ({synonymEdgeCount})</span></label>");
        if (jobEdgeCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#26a69a\"><input type=\"checkbox\" value=\"job\" checked onchange=\"toggleEdgeFilter(this)\"><span>Job &rarr; Table/Proc ({jobEdgeCount})</span></label>");
        if (extEdgeCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#ff6b6b\"><input type=\"checkbox\" value=\"external\" checked onchange=\"toggleEdgeFilter(this)\"><span>Cross-DB ({extEdgeCount})</span></label>");
        sb.AppendLine("<label class=\"filter-toggle\" style=\"--clr:#e94560\"><input type=\"checkbox\" value=\"cycles\" onchange=\"toggleCycleFilter(this)\"><span>&#10227; Cycles</span></label>");
        sb.AppendLine("</div>");

        sb.AppendLine("<div id=\"graph-container\"><svg id=\"dep-graph\"></svg></div>");

        // Dependency ranking table
        if (connected.Count > 0)
        {
            sb.AppendLine("<h3>Importance Ranking</h3>");
            sb.AppendLine("<p class=\"meta\">Objects ranked by how central they are. \"Referenced By\" = other objects depend on this one. \"Impact\" = total objects transitively affected.</p>");
            sb.AppendLine("<table><thead><tr><th>Rank</th><th>Object</th><th>Type</th><th>Referenced By</th><th>Depends On</th><th>Transitive Impact</th><th>Score</th></tr></thead><tbody>");

            var rank = 1;
            foreach (var dep in connected.OrderByDescending(d => d.ImportanceScore))
            {
                var impactClass = dep.TransitiveImpact.Count > 10 ? "error" : dep.TransitiveImpact.Count > 5 ? "warn" : "";
                var typeClass = dep.ObjectType switch { "View" => "ok", "Procedure" => "warn", "Function" => "info", "Trigger" => "warn", "Synonym" => "info", "Job" => "ok", "External" => "error", _ => "" };
                sb.AppendLine($"<tr><td>{rank++}</td><td><strong>{E(dep.FullName)}</strong></td><td class=\"{typeClass}\">{dep.ObjectType}</td>");
                sb.AppendLine($"<td>{dep.ReferencedBy.Count}</td>");
                sb.AppendLine($"<td>{dep.DependsOn.Count}</td>");
                sb.AppendLine($"<td class=\"{impactClass}\">{dep.TransitiveImpact.Count}</td>");
                sb.AppendLine($"<td>{dep.ImportanceScore}</td></tr>");
            }
            sb.AppendLine("</tbody></table>");

            // Impact details (expandable per core table)
            var coreTables = connected
                .Where(d => d.ReferencedBy.Count > 0)
                .OrderByDescending(d => d.TransitiveImpact.Count)
                .ToList();

            if (coreTables.Count > 0)
            {
                sb.AppendLine("<h3>Impact Analysis</h3>");
                sb.AppendLine("<p class=\"meta\">If you modify a core table, these tables are affected (directly or transitively).</p>");

                foreach (var dep in coreTables)
                {
                    sb.AppendLine($"<details><summary><strong>{E(dep.FullName)}</strong> — {dep.ReferencedBy.Count} direct, {dep.TransitiveImpact.Count} total impact</summary>");
                    sb.AppendLine("<div class=\"impact-detail\">");

                    sb.AppendLine("<div class=\"impact-col\"><h4>Direct dependents</h4><ul>");
                    foreach (var t in dep.ReferencedBy.Order())
                        sb.AppendLine($"<li>{E(t)}</li>");
                    sb.AppendLine("</ul></div>");

                    if (dep.TransitiveImpact.Count > dep.ReferencedBy.Count)
                    {
                        var indirect = dep.TransitiveImpact.Except(dep.ReferencedBy, StringComparer.OrdinalIgnoreCase).Order();
                        sb.AppendLine("<div class=\"impact-col\"><h4>Indirect (transitive)</h4><ul>");
                        foreach (var t in indirect)
                            sb.AppendLine($"<li class=\"meta\">{E(t)}</li>");
                        sb.AppendLine("</ul></div>");
                    }

                    sb.AppendLine("<div class=\"impact-col\"><h4>This table depends on</h4><ul>");
                    foreach (var t in dep.DependsOn.Order())
                        sb.AppendLine($"<li>{E(t)}</li>");
                    if (dep.DependsOn.Count == 0)
                        sb.AppendLine("<li class=\"meta\">None (root table)</li>");
                    sb.AppendLine("</ul></div>");

                    sb.AppendLine("</div></details>");
                }
            }
        }

        // Orphaned tables
        if (orphaned.Count > 0)
        {
            sb.AppendLine("<details><summary><h3 style=\"display:inline\">Standalone Tables</h3> <span class=\"meta\">(" + orphaned.Count + " tables with no FK relationships)</span></summary><ul>");
            foreach (var dep in orphaned.OrderBy(d => d.FullName))
                sb.AppendLine($"<li>{E(dep.FullName)}</li>");
            sb.AppendLine("</ul></details>");
        }

        sb.AppendLine("</section>");
    }

    private void BuildSchemaSection(StringBuilder sb, AnalysisResult result)
    {
        var schema = result.Schema!;
        sb.AppendLine("<section id=\"schema\">");
        sb.AppendLine("<h2>Schema Overview</h2>");

        sb.AppendLine("<div class=\"summary-grid\">");
        sb.AppendLine($"<div class=\"card\"><h3>{schema.Tables.Count}</h3><p>Tables</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{schema.Views.Count}</h3><p>Views</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{schema.StoredProcedures.Count}</h3><p>Stored Procedures</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{schema.Functions.Count}</h3><p>Functions</p></div>");
        if (schema.Triggers.Count > 0)
            sb.AppendLine($"<div class=\"card\"><h3>{schema.Triggers.Count}</h3><p>Triggers</p></div>");
        if (schema.Synonyms.Count > 0)
            sb.AppendLine($"<div class=\"card\"><h3>{schema.Synonyms.Count}</h3><p>Synonyms</p></div>");
        if (schema.Sequences.Count > 0)
            sb.AppendLine($"<div class=\"card\"><h3>{schema.Sequences.Count}</h3><p>Sequences</p></div>");
        if (schema.UserDefinedTypes.Count > 0)
            sb.AppendLine($"<div class=\"card\"><h3>{schema.UserDefinedTypes.Count}</h3><p>User-Defined Types</p></div>");
        if (schema.Jobs.Count > 0)
            sb.AppendLine($"<div class=\"card\"><h3>{schema.Jobs.Count}</h3><p>SQL Agent Jobs</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{schema.Tables.Sum(t => t.Columns.Count)}</h3><p>Total Columns</p></div>");
        sb.AppendLine("</div>");

        foreach (var table in schema.Tables)
        {
            sb.AppendLine($"<h3 id=\"table-{E(table.FullName)}\">{E(table.FullName)}</h3>");
            sb.AppendLine("<table><thead><tr><th>Column</th><th>Type</th><th>Nullable</th><th>PK</th><th>Identity</th><th>Default</th></tr></thead><tbody>");

            foreach (var col in table.Columns)
            {
                var typeStr = col.MaxLength.HasValue
                    ? $"{col.DataType}({(col.MaxLength == -1 ? "MAX" : col.MaxLength.ToString())})"
                    : col.Precision.HasValue
                        ? $"{col.DataType}({col.Precision},{col.Scale})"
                        : col.DataType;

                sb.AppendLine($"<tr><td>{E(col.Name)}</td><td>{typeStr}</td>");
                sb.AppendLine($"<td>{(col.IsNullable ? "<span class=\"warn\">YES</span>" : "NO")}</td>");
                sb.AppendLine($"<td>{(col.IsPrimaryKey ? "<span class=\"ok\">PK</span>" : "")}</td>");
                sb.AppendLine($"<td>{(col.IsIdentity ? "Yes" : "")}</td>");
                sb.AppendLine($"<td>{E(col.DefaultValue ?? "")}</td></tr>");
            }

            sb.AppendLine("</tbody></table>");

            if (table.Indexes.Count > 0)
            {
                sb.AppendLine("<details><summary>Indexes</summary>");
                sb.AppendLine("<table><thead><tr><th>Name</th><th>Type</th><th>Unique</th><th>Columns</th></tr></thead><tbody>");
                foreach (var idx in table.Indexes)
                {
                    sb.AppendLine($"<tr><td>{E(idx.Name)}</td><td>{idx.Type}</td><td>{(idx.IsUnique ? "Yes" : "No")}</td><td>{E(string.Join(", ", idx.Columns))}</td></tr>");
                }
                sb.AppendLine("</tbody></table></details>");
            }
        }

        // Triggers
        if (schema.Triggers.Count > 0)
        {
            sb.AppendLine("<h3>Triggers</h3>");
            sb.AppendLine("<table><thead><tr><th>Trigger</th><th>Parent Table</th><th>Type</th><th>Events</th><th>Enabled</th></tr></thead><tbody>");
            foreach (var tr in schema.Triggers)
            {
                var enabledLabel = tr.IsEnabled ? "<span class=\"ok\">Yes</span>" : "<span class=\"error\">No</span>";
                sb.AppendLine($"<tr><td>{E(tr.FullName)}</td><td>{E(tr.ParentFullName)}</td><td>{tr.TriggerType}</td><td>{E(tr.TriggerEvents)}</td><td>{enabledLabel}</td></tr>");
            }
            sb.AppendLine("</tbody></table>");
        }

        // Synonyms
        if (schema.Synonyms.Count > 0)
        {
            sb.AppendLine("<h3>Synonyms</h3>");
            sb.AppendLine("<table><thead><tr><th>Synonym</th><th>Base Object</th></tr></thead><tbody>");
            foreach (var syn in schema.Synonyms)
            {
                sb.AppendLine($"<tr><td>{E(syn.FullName)}</td><td>{E(syn.BaseObjectName)}</td></tr>");
            }
            sb.AppendLine("</tbody></table>");
        }

        // Sequences
        if (schema.Sequences.Count > 0)
        {
            sb.AppendLine("<h3>Sequences</h3>");
            sb.AppendLine("<table><thead><tr><th>Sequence</th><th>Data Type</th><th>Current</th><th>Increment</th><th>Min</th><th>Max</th><th>Cycling</th></tr></thead><tbody>");
            foreach (var seq in schema.Sequences)
            {
                sb.AppendLine($"<tr><td>{E(seq.FullName)}</td><td>{seq.DataType}</td><td>{seq.CurrentValue:N0}</td><td>{seq.Increment}</td><td>{seq.MinValue:N0}</td><td>{seq.MaxValue:N0}</td><td>{(seq.IsCycling ? "Yes" : "No")}</td></tr>");
            }
            sb.AppendLine("</tbody></table>");
        }

        // User-Defined Types
        if (schema.UserDefinedTypes.Count > 0)
        {
            sb.AppendLine("<h3>User-Defined Types</h3>");
            sb.AppendLine("<table><thead><tr><th>Type</th><th>Base Type</th><th>Table Type</th><th>Nullable</th><th>Max Length</th></tr></thead><tbody>");
            foreach (var udt in schema.UserDefinedTypes)
            {
                sb.AppendLine($"<tr><td>{E(udt.FullName)}</td><td>{udt.BaseType}</td><td>{(udt.IsTableType ? "Yes" : "No")}</td><td>{(udt.IsNullable ? "Yes" : "No")}</td><td>{(udt.MaxLength.HasValue ? udt.MaxLength.ToString() : "N/A")}</td></tr>");
            }
            sb.AppendLine("</tbody></table>");
        }

        sb.AppendLine("</section>");
    }

    private void BuildProfilingSection(StringBuilder sb, AnalysisResult result)
    {
        sb.AppendLine("<section id=\"profiling\">");
        sb.AppendLine("<h2>Data Profiling</h2>");

        foreach (var profile in result.Profiles!)
        {
            sb.AppendLine($"<h3>{E(profile.FullName)} <span class=\"meta\">({profile.RowCount:N0} rows)</span></h3>");

            if (profile.RowCount == 0)
            {
                sb.AppendLine("<p class=\"meta\">Empty table</p>");
                continue;
            }

            sb.AppendLine("<table><thead><tr><th>Column</th><th>Type</th><th>Null %</th><th>Distinct</th><th>Min</th><th>Max</th></tr></thead><tbody>");

            foreach (var col in profile.ColumnProfiles)
            {
                var nullClass = col.NullPercentage > 50 ? "error" : col.NullPercentage > 0 ? "warn" : "ok";
                sb.AppendLine($"<tr><td>{E(col.ColumnName)}</td><td>{col.DataType}</td>");
                sb.AppendLine($"<td class=\"{nullClass}\">{col.NullPercentage:F1}%</td>");
                sb.AppendLine($"<td>{col.DistinctCount:N0}</td>");
                sb.AppendLine($"<td>{E(Truncate(col.MinValue, 40))}</td>");
                sb.AppendLine($"<td>{E(Truncate(col.MaxValue, 40))}</td></tr>");
            }

            sb.AppendLine("</tbody></table>");
        }

        sb.AppendLine("</section>");
    }

    private void BuildRelationshipsSection(StringBuilder sb, AnalysisResult result)
    {
        var map = result.Relationships!;
        sb.AppendLine("<section id=\"relationships\">");
        sb.AppendLine("<h2>Relationships Detail</h2>");

        if (map.ExplicitRelationships.Count > 0)
        {
            sb.AppendLine("<h3>Explicit Foreign Keys</h3>");
            sb.AppendLine("<table><thead><tr><th>Name</th><th>From</th><th>To</th><th>Delete</th><th>Update</th></tr></thead><tbody>");
            foreach (var fk in map.ExplicitRelationships)
            {
                sb.AppendLine($"<tr><td>{E(fk.Name)}</td>");
                sb.AppendLine($"<td>{E(fk.FromSchema)}.{E(fk.FromTable)}.{E(fk.FromColumn)}</td>");
                sb.AppendLine($"<td>{E(fk.ToSchema)}.{E(fk.ToTable)}.{E(fk.ToColumn)}</td>");
                sb.AppendLine($"<td>{fk.DeleteRule}</td><td>{fk.UpdateRule}</td></tr>");
            }
            sb.AppendLine("</tbody></table>");
        }

        if (map.ViewDependencies.Count > 0)
        {
            sb.AppendLine("<h3>Object Dependencies (Views, Procedures, Functions)</h3>");
            sb.AppendLine("<table><thead><tr><th>Object</th><th>Type</th><th>Depends On</th><th>Target Type</th><th>Database</th></tr></thead><tbody>");
            foreach (var vd in map.ViewDependencies)
            {
                var dbLabel = vd.IsCrossDatabase ? $"<span class=\"error\">{E(vd.ToDatabase!)}</span>" : "<span class=\"meta\">local</span>";
                sb.AppendLine($"<tr><td>{E(vd.FromSchema)}.{E(vd.FromName)}</td><td>{vd.FromType}</td>");
                sb.AppendLine($"<td>{E(vd.ToFullName)}</td><td>{vd.ToType}</td><td>{dbLabel}</td></tr>");
            }
            sb.AppendLine("</tbody></table>");
        }

        if (map.ImplicitRelationships.Count > 0)
        {
            sb.AppendLine("<h3>Implicit (Detected) Relationships</h3>");
            sb.AppendLine("<table><thead><tr><th>From</th><th>To</th><th>Confidence</th><th>Reason</th></tr></thead><tbody>");
            foreach (var rel in map.ImplicitRelationships)
            {
                sb.AppendLine($"<tr><td>{E(rel.FromSchema)}.{E(rel.FromTable)}.{E(rel.FromColumn)}</td>");
                sb.AppendLine($"<td>{E(rel.ToSchema)}.{E(rel.ToTable)}.{E(rel.ToColumn)}</td>");
                sb.AppendLine($"<td>{rel.Confidence:P0}</td><td>{E(rel.Reason)}</td></tr>");
            }
            sb.AppendLine("</tbody></table>");
        }

        sb.AppendLine("</section>");
    }

    private void BuildQualitySection(StringBuilder sb, AnalysisResult result)
    {
        var issues = result.QualityIssues!;
        sb.AppendLine("<section id=\"quality\">");
        sb.AppendLine("<h2>Quality Issues</h2>");

        if (issues.Count == 0)
        {
            sb.AppendLine("<p class=\"ok\">No quality issues found.</p>");
            sb.AppendLine("</section>");
            return;
        }

        var grouped = issues.GroupBy(i => i.Severity).OrderByDescending(g => g.Key);
        foreach (var group in grouped)
        {
            var cssClass = group.Key switch
            {
                IssueSeverity.Error => "error",
                IssueSeverity.Warning => "warn",
                _ => "info"
            };

            sb.AppendLine($"<h3 class=\"{cssClass}\">{group.Key} ({group.Count()})</h3>");
            sb.AppendLine("<table><thead><tr><th>Object</th><th>Category</th><th>Issue</th><th>Recommendation</th></tr></thead><tbody>");
            foreach (var issue in group)
            {
                sb.AppendLine($"<tr><td>{E(issue.ObjectName)}</td><td>{issue.Category}</td>");
                sb.AppendLine($"<td>{E(issue.Description)}</td><td>{E(issue.Recommendation ?? "")}</td></tr>");
            }
            sb.AppendLine("</tbody></table>");
        }

        sb.AppendLine("</section>");
    }

    private static string E(string text) => HttpUtility.HtmlEncode(text);

    private static string Truncate(string? value, int maxLength)
    {
        if (string.IsNullOrEmpty(value)) return "";
        return value.Length <= maxLength ? value : value[..maxLength] + "...";
    }

    private string GetGraphJs(AnalysisResult result)
    {
        var deps = result.Relationships!.Dependencies;
        var fks = result.Relationships!.ExplicitRelationships;
        var viewDeps = result.Relationships!.ViewDependencies;

        // Build nodes array
        var connected = deps.Where(d => d.DirectConnections > 0).ToList();
        var nodeIndex = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
        var nodes = new List<object>();
        for (var i = 0; i < connected.Count; i++)
        {
            var d = connected[i];
            nodeIndex[d.FullName] = i;
            nodes.Add(new
            {
                id = d.FullName,
                label = d.IsExternal ? d.FullName : $"{d.SchemaName}.{d.TableName}",
                type = d.ObjectType.ToLowerInvariant(),
                refBy = d.ReferencedBy.Count,
                depOn = d.DependsOn.Count,
                impact = d.TransitiveImpact.Count,
                score = d.ImportanceScore
            });
        }

        // Build edges (deduplicated at object level)
        var edgeSet = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        var edges = new List<object>();
        foreach (var fk in fks)
        {
            var from = $"{fk.FromSchema}.{fk.FromTable}";
            var to = $"{fk.ToSchema}.{fk.ToTable}";
            var key = $"{from}->{to}";
            if (!edgeSet.Add(key)) continue;
            if (!nodeIndex.ContainsKey(from) || !nodeIndex.ContainsKey(to)) continue;
            edges.Add(new { source = nodeIndex[from], target = nodeIndex[to], type = "fk", fromType = "Table", toType = "Table", label = $"{from} → {to}" });
        }

        // Add object dependency edges (views, procedures, functions, cross-DB)
        foreach (var vd in viewDeps)
        {
            var from = $"{vd.FromSchema}.{vd.FromName}";
            var to = vd.ToFullName;
            var key = $"{from}->{to}";
            if (!edgeSet.Add(key)) continue;
            if (!nodeIndex.ContainsKey(from) || !nodeIndex.ContainsKey(to)) continue;
            var edgeType = vd.IsCrossDatabase ? "external" : vd.FromType.ToLowerInvariant();
            edges.Add(new { source = nodeIndex[from], target = nodeIndex[to], type = edgeType, fromType = vd.FromType, toType = vd.ToType, label = $"{from} → {to}" });
        }

        var nodesJson = JsonSerializer.Serialize(nodes);
        var edgesJson = JsonSerializer.Serialize(edges);

        return $$"""
const graphNodes = {{nodesJson}};
const graphEdges = {{edgesJson}};

(function() {
    const svg = document.getElementById('dep-graph');
    const container = document.getElementById('graph-container');
    const width = container.clientWidth || 1200;
    const height = Math.max(600, Math.min(graphNodes.length * 12, 1000));
    svg.setAttribute('width', width);
    svg.setAttribute('height', height);

    // Zoom/pan state
    let vb = { x: 0, y: 0, w: width, h: height };
    const updateViewBox = () => svg.setAttribute('viewBox', `${vb.x} ${vb.y} ${vb.w} ${vb.h}`);
    updateViewBox();

    // Convert screen coords to world (SVG) coords
    function screenToWorld(sx, sy) {
        const rect = svg.getBoundingClientRect();
        return {
            x: vb.x + (sx - rect.left) / rect.width * vb.w,
            y: vb.y + (sy - rect.top) / rect.height * vb.h
        };
    }

    const maxScore = Math.max(...graphNodes.map(n => n.score), 1);

    // Initialize positions in a circle
    graphNodes.forEach((n, i) => {
        const angle = (2 * Math.PI * i) / graphNodes.length;
        const r = Math.min(width, height) * 0.35;
        n.x = width / 2 + r * Math.cos(angle);
        n.y = height / 2 + r * Math.sin(angle);
        n.vx = 0;
        n.vy = 0;
        n.radius = 6 + (n.score / maxScore) * 20;
    });

    // SVG defs
    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
    marker.setAttribute('id', 'arrow');
    marker.setAttribute('viewBox', '0 0 10 10');
    marker.setAttribute('refX', '10');
    marker.setAttribute('refY', '5');
    marker.setAttribute('markerWidth', '6');
    marker.setAttribute('markerHeight', '6');
    marker.setAttribute('orient', 'auto-start-reverse');
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
    path.setAttribute('fill', '#4fc3f7');
    marker.appendChild(path);
    defs.appendChild(marker);
    svg.appendChild(defs);

    const edgeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const nodeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const labelGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    svg.appendChild(edgeGroup);
    svg.appendChild(nodeGroup);
    svg.appendChild(labelGroup);

    // Tooltip
    const tooltip = document.createElement('div');
    tooltip.className = 'graph-tooltip';
    container.appendChild(tooltip);

    // Zoom controls
    const controls = document.createElement('div');
    controls.className = 'graph-controls';
    controls.innerHTML = '<button id="zoom-in" title="Zoom in">+</button><button id="zoom-out" title="Zoom out">&minus;</button><button id="zoom-fit" title="Fit all">&#8634;</button><button id="dep-reorder" title="Auto-layout (connection-aware)">&#9638;</button><button id="dep-fs" title="Fullscreen">&#x26F6;</button>';
    container.appendChild(controls);

    // Create edge elements
    const edgeColors = { fk: '#4fc3f7', view: '#4ecca3', procedure: '#f0a500', function: '#bb86fc', trigger: '#ff7043', synonym: '#78909c', job: '#26a69a', external: '#ff6b6b' };
    const edgeEls = graphEdges.map((e, i) => {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        const color = edgeColors[e.type] || '#4fc3f7';
        line.setAttribute('stroke', color);
        line.setAttribute('stroke-opacity', '0.4');
        line.setAttribute('stroke-width', '1.5');
        if (e.type !== 'fk') line.setAttribute('stroke-dasharray', '6,3');
        line.setAttribute('marker-end', 'url(#arrow)');
        line.style.cursor = 'pointer';
        edgeGroup.appendChild(line);
        return line;
    });

    // Edge hover tooltips
    edgeEls.forEach((el, i) => {
        const e = graphEdges[i];
        el.addEventListener('mouseenter', (ev) => {
            tooltip.innerHTML = `<strong>${e.fromType} &rarr; ${e.toType}</strong><br>${e.label}`;
            tooltip.style.display = 'block';
            const cr = container.getBoundingClientRect();
            tooltip.style.left = (ev.clientX - cr.left + 15) + 'px';
            tooltip.style.top = (ev.clientY - cr.top - 10) + 'px';
            el.setAttribute('stroke-opacity', '1');
            el.setAttribute('stroke-width', '3');
        });
        el.addEventListener('mousemove', (ev) => {
            const cr = container.getBoundingClientRect();
            tooltip.style.left = (ev.clientX - cr.left + 15) + 'px';
            tooltip.style.top = (ev.clientY - cr.top - 10) + 'px';
        });
        el.addEventListener('mouseleave', () => {
            tooltip.style.display = 'none';
            el.setAttribute('stroke-opacity', '0.4');
            el.setAttribute('stroke-width', '1.5');
        });
    });

    // Create node elements
    const nodeEls = graphNodes.map((n, i) => {
        if (n.type === 'view') {
            const diamond = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            diamond.setAttribute('fill', '#4ecca3');
            diamond.setAttribute('stroke', '#e0e0e0');
            diamond.setAttribute('stroke-width', '1');
            diamond.setAttribute('cursor', 'grab');
            nodeGroup.appendChild(diamond);
            return diamond;
        }
        if (n.type === 'procedure') {
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('fill', '#f0a500');
            rect.setAttribute('stroke', '#e0e0e0');
            rect.setAttribute('stroke-width', '1');
            rect.setAttribute('cursor', 'grab');
            nodeGroup.appendChild(rect);
            return rect;
        }
        if (n.type === 'function') {
            const tri = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            tri.setAttribute('fill', '#bb86fc');
            tri.setAttribute('stroke', '#e0e0e0');
            tri.setAttribute('stroke-width', '1');
            tri.setAttribute('cursor', 'grab');
            nodeGroup.appendChild(tri);
            return tri;
        }
        if (n.type === 'trigger') {
            // Star/bolt shape (rotated diamond with notch)
            const star = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            star.setAttribute('fill', '#ff7043');
            star.setAttribute('stroke', '#e0e0e0');
            star.setAttribute('stroke-width', '1');
            star.setAttribute('cursor', 'grab');
            nodeGroup.appendChild(star);
            return star;
        }
        if (n.type === 'synonym') {
            // Rounded rect (pill shape)
            const pill = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            pill.setAttribute('fill', '#78909c');
            pill.setAttribute('stroke', '#e0e0e0');
            pill.setAttribute('stroke-width', '1');
            pill.setAttribute('cursor', 'grab');
            nodeGroup.appendChild(pill);
            return pill;
        }
        if (n.type === 'job') {
            const hex = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            hex.setAttribute('fill', '#26a69a');
            hex.setAttribute('stroke', '#e0e0e0');
            hex.setAttribute('stroke-width', '1');
            hex.setAttribute('cursor', 'grab');
            nodeGroup.appendChild(hex);
            return hex;
        }
        if (n.type === 'external') {
            const diamond = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            diamond.setAttribute('fill', 'none');
            diamond.setAttribute('stroke', '#ff6b6b');
            diamond.setAttribute('stroke-width', '2');
            diamond.setAttribute('stroke-dasharray', '4,2');
            diamond.setAttribute('cursor', 'grab');
            nodeGroup.appendChild(diamond);
            return diamond;
        }
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('r', n.radius);
        const hue = n.refBy > 0 ? (n.refBy > 5 ? 0 : 30) : 200;
        circle.setAttribute('fill', `hsl(${hue}, 70%, ${50 + (n.score / maxScore) * 20}%)`);
        circle.setAttribute('stroke', '#e0e0e0');
        circle.setAttribute('stroke-width', '1');
        circle.setAttribute('cursor', 'grab');
        nodeGroup.appendChild(circle);
        return circle;
    });

    // Hover/tooltip
    nodeEls.forEach((el, i) => {
        const n = graphNodes[i];
        el.addEventListener('mouseenter', (ev) => {
            tooltip.innerHTML = `<strong>${n.id}</strong><br>Type: ${n.type.charAt(0).toUpperCase() + n.type.slice(1)}<br>Referenced by: ${n.refBy}<br>Depends on: ${n.depOn}<br>Impact: ${n.impact}<br>Score: ${n.score}`;
            tooltip.style.display = 'block';
            const cr = container.getBoundingClientRect();
            tooltip.style.left = (ev.clientX - cr.left + 15) + 'px';
            tooltip.style.top = (ev.clientY - cr.top - 10) + 'px';
            graphEdges.forEach((e, ei) => {
                if (e.source === i || e.target === i) {
                    edgeEls[ei].setAttribute('stroke-opacity', '1');
                    edgeEls[ei].setAttribute('stroke-width', '2.5');
                }
            });
            el.setAttribute('stroke-width', '3');
        });
        el.addEventListener('mouseleave', () => {
            tooltip.style.display = 'none';
            graphEdges.forEach((e, ei) => {
                edgeEls[ei].setAttribute('stroke-opacity', '0.4');
                edgeEls[ei].setAttribute('stroke-width', '1.5');
            });
            el.setAttribute('stroke-width', '1');
        });
    });

    // Labels
    const labelEls = graphNodes.map(n => {
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.textContent = n.label;
        text.setAttribute('font-size', Math.max(9, Math.min(13, 8 + n.radius / 4)));
        text.setAttribute('fill', '#e0e0e0');
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('pointer-events', 'none');
        labelGroup.appendChild(text);
        return text;
    });

    // --- Zoom ---
    function zoomBy(factor, cx, cy) {
        const newW = vb.w / factor, newH = vb.h / factor;
        vb.x = cx - (cx - vb.x) / factor;
        vb.y = cy - (cy - vb.y) / factor;
        vb.w = newW;
        vb.h = newH;
        updateViewBox();
    }

    svg.addEventListener('wheel', (ev) => {
        ev.preventDefault();
        const p = screenToWorld(ev.clientX, ev.clientY);
        const factor = ev.deltaY < 0 ? 1.15 : 1 / 1.15;
        zoomBy(factor, p.x, p.y);
    }, { passive: false });

    document.getElementById('zoom-in').addEventListener('click', () => {
        const cx = vb.x + vb.w / 2, cy = vb.y + vb.h / 2;
        zoomBy(1.3, cx, cy);
    });
    document.getElementById('zoom-out').addEventListener('click', () => {
        const cx = vb.x + vb.w / 2, cy = vb.y + vb.h / 2;
        zoomBy(1 / 1.3, cx, cy);
    });
    function fitAllDep() {
        let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
        graphNodes.forEach((n,i) => {
            if (nodeEls[i].getAttribute('visibility') === 'hidden') return;
            minX=Math.min(minX,n.x-n.radius-20); minY=Math.min(minY,n.y-n.radius-20);
            maxX=Math.max(maxX,n.x+n.radius+20); maxY=Math.max(maxY,n.y+n.radius+20);
        });
        if (minX===Infinity) { vb={x:0,y:0,w:width,h:height}; updateViewBox(); return; }
        const pad=60;
        vb={x:minX-pad, y:minY-pad, w:maxX-minX+pad*2, h:maxY-minY+pad*2};
        updateViewBox();
    }
    document.getElementById('zoom-fit').addEventListener('click', () => { fitAllDep(); });

    // --- Auto-layout (force-directed re-spread) ---
    let simRunning = true;
    document.getElementById('dep-reorder').addEventListener('click', () => {
        const cw = container.clientWidth || 1200;
        const ch = container.clientHeight || 800;
        const area = Math.max(cw, ch) * Math.sqrt(graphNodes.length) * 1.0;
        const cx0 = area / 2, cy0 = area / 2;
        graphNodes.forEach((n, i) => {
            const angle = (2 * Math.PI * i) / graphNodes.length;
            const radius = area * 0.38;
            n.x = cx0 + Math.cos(angle) * radius * (0.8 + Math.random() * 0.4);
            n.y = cy0 + Math.sin(angle) * radius * (0.8 + Math.random() * 0.4);
            n.vx = 0; n.vy = 0;
        });
        simRunning = true;
        setTimeout(() => fitAllDep(), 2000);
    });

    // --- Fullscreen ---
    const depFsBtn = document.getElementById('dep-fs');
    depFsBtn.addEventListener('click', () => {
        if (document.fullscreenElement) {
            document.exitFullscreen();
        } else {
            container.requestFullscreen().catch(() => {});
        }
    });
    document.addEventListener('fullscreenchange', () => {
        if (document.fullscreenElement === container) {
            container.style.height = '100vh';
            container.style.borderRadius = '0';
            svg.setAttribute('width', screen.width);
            svg.setAttribute('height', screen.height);
            depFsBtn.textContent = '\u2716'; depFsBtn.title = 'Exit fullscreen';
        } else if (!document.fullscreenElement || document.fullscreenElement.id !== 'graph-container') {
            container.style.height = '';
            container.style.borderRadius = '';
            svg.setAttribute('width', container.clientWidth || width);
            svg.setAttribute('height', height);
            depFsBtn.textContent = '\u26F6'; depFsBtn.title = 'Fullscreen';
        }
        fitAllDep();
    });

    // --- Drag nodes + Pan ---
    let dragNode = null, dragOffset = {x:0,y:0};
    let isPanning = false, panStart = {x:0,y:0}, vbStart = {x:0,y:0};

    svg.addEventListener('mousedown', (ev) => {
        const p = screenToWorld(ev.clientX, ev.clientY);
        // Check if clicking a node
        for (let i = 0; i < graphNodes.length; i++) {
            const n = graphNodes[i];
            if (Math.hypot(p.x - n.x, p.y - n.y) < n.radius + 5) {
                dragNode = i;
                dragOffset = { x: p.x - n.x, y: p.y - n.y };
                graphNodes[i].fx = n.x;
                graphNodes[i].fy = n.y;
                svg.style.cursor = 'grabbing';
                return;
            }
        }
        // Otherwise start panning
        isPanning = true;
        panStart = { x: ev.clientX, y: ev.clientY };
        vbStart = { x: vb.x, y: vb.y };
        svg.style.cursor = 'move';
    });

    svg.addEventListener('mousemove', (ev) => {
        if (dragNode !== null) {
            const p = screenToWorld(ev.clientX, ev.clientY);
            graphNodes[dragNode].fx = p.x - dragOffset.x;
            graphNodes[dragNode].fy = p.y - dragOffset.y;
        } else if (isPanning) {
            const rect = svg.getBoundingClientRect();
            const dx = (ev.clientX - panStart.x) / rect.width * vb.w;
            const dy = (ev.clientY - panStart.y) / rect.height * vb.h;
            vb.x = vbStart.x - dx;
            vb.y = vbStart.y - dy;
            updateViewBox();
        }
    });

    svg.addEventListener('mouseup', () => {
        if (dragNode !== null) {
            graphNodes[dragNode].x = graphNodes[dragNode].fx;
            graphNodes[dragNode].y = graphNodes[dragNode].fy;
            delete graphNodes[dragNode].fx;
            delete graphNodes[dragNode].fy;
        }
        dragNode = null;
        isPanning = false;
        svg.style.cursor = 'default';
    });

    svg.addEventListener('mouseleave', () => {
        isPanning = false;
        if (dragNode !== null) {
            graphNodes[dragNode].x = graphNodes[dragNode].fx;
            graphNodes[dragNode].y = graphNodes[dragNode].fy;
            delete graphNodes[dragNode].fx;
            delete graphNodes[dragNode].fy;
            dragNode = null;
        }
        svg.style.cursor = 'default';
    });

    // Force simulation
    function tick() {
        const N = graphNodes.length;
        for (let i = 0; i < N; i++) {
            for (let j = i + 1; j < N; j++) {
                let dx = graphNodes[i].x - graphNodes[j].x;
                let dy = graphNodes[i].y - graphNodes[j].y;
                let dist = Math.sqrt(dx*dx + dy*dy) || 1;
                let force = 2500 / (dist * dist);
                let fx = dx / dist * force;
                let fy = dy / dist * force;
                graphNodes[i].vx += fx;
                graphNodes[i].vy += fy;
                graphNodes[j].vx -= fx;
                graphNodes[j].vy -= fy;
            }
        }
        graphEdges.forEach(e => {
            let s = graphNodes[e.source], t = graphNodes[e.target];
            let dx = t.x - s.x, dy = t.y - s.y;
            let dist = Math.sqrt(dx*dx + dy*dy) || 1;
            let force = (dist - 180) * 0.004;
            let fx = dx / dist * force;
            let fy = dy / dist * force;
            s.vx += fx; s.vy += fy;
            t.vx -= fx; t.vy -= fy;
        });
        graphNodes.forEach(n => {
            n.vx += (width/2 - n.x) * 0.0006;
            n.vy += (height/2 - n.y) * 0.0006;
        });
        graphNodes.forEach((n, i) => {
            if (i === dragNode) {
                n.x = n.fx; n.y = n.fy;
                n.vx = 0; n.vy = 0;
                return;
            }
            n.vx *= 0.85;
            n.vy *= 0.85;
            n.x += n.vx;
            n.y += n.vy;
        });
        // Update SVG
        graphEdges.forEach((e, i) => {
            let s = graphNodes[e.source], t = graphNodes[e.target];
            let dx = t.x - s.x, dy = t.y - s.y;
            let dist = Math.sqrt(dx*dx + dy*dy) || 1;
            let offsetS = s.radius / dist, offsetT = t.radius / dist;
            edgeEls[i].setAttribute('x1', s.x + dx * offsetS);
            edgeEls[i].setAttribute('y1', s.y + dy * offsetS);
            edgeEls[i].setAttribute('x2', t.x - dx * offsetT);
            edgeEls[i].setAttribute('y2', t.y - dy * offsetT);
        });
        nodeEls.forEach((el, i) => {
            const n = graphNodes[i];
            if (n.type === 'view') {
                const r = n.radius;
                el.setAttribute('points', `${n.x},${n.y-r} ${n.x+r},${n.y} ${n.x},${n.y+r} ${n.x-r},${n.y}`);
            } else if (n.type === 'procedure') {
                const r = n.radius;
                el.setAttribute('x', n.x - r);
                el.setAttribute('y', n.y - r);
                el.setAttribute('width', r * 2);
                el.setAttribute('height', r * 2);
                el.setAttribute('rx', '3');
            } else if (n.type === 'function') {
                const r = n.radius;
                el.setAttribute('points', `${n.x},${n.y-r} ${n.x+r},${n.y+r} ${n.x-r},${n.y+r}`);
            } else if (n.type === 'trigger') {
                const r = n.radius;
                // 5-point star
                let pts = '';
                for (let k = 0; k < 5; k++) {
                    const outerAngle = (Math.PI * 2 * k / 5) - Math.PI / 2;
                    const innerAngle = outerAngle + Math.PI / 5;
                    pts += `${n.x + r * Math.cos(outerAngle)},${n.y + r * Math.sin(outerAngle)} `;
                    pts += `${n.x + r * 0.45 * Math.cos(innerAngle)},${n.y + r * 0.45 * Math.sin(innerAngle)} `;
                }
                el.setAttribute('points', pts.trim());
            } else if (n.type === 'synonym') {
                const r = n.radius;
                el.setAttribute('x', n.x - r * 1.3);
                el.setAttribute('y', n.y - r * 0.7);
                el.setAttribute('width', r * 2.6);
                el.setAttribute('height', r * 1.4);
                el.setAttribute('rx', r * 0.7);
            } else if (n.type === 'job') {
                const r = n.radius;
                const a = Math.PI / 3;
                let pts = '';
                for (let k = 0; k < 6; k++) {
                    const angle = a * k - Math.PI / 6;
                    pts += `${n.x + r * Math.cos(angle)},${n.y + r * Math.sin(angle)} `;
                }
                el.setAttribute('points', pts.trim());
            } else if (n.type === 'external') {
                const r = n.radius;
                el.setAttribute('points', `${n.x},${n.y-r} ${n.x+r},${n.y} ${n.x},${n.y+r} ${n.x-r},${n.y}`);
            } else {
                el.setAttribute('cx', n.x);
                el.setAttribute('cy', n.y);
            }
        });
        labelEls.forEach((el, i) => {
            el.setAttribute('x', graphNodes[i].x);
            el.setAttribute('y', graphNodes[i].y + graphNodes[i].radius + 14);
        });
        requestAnimationFrame(tick);
    }
    tick();

    // --- Filtering ---
    const hiddenNodeTypes = new Set();
    const hiddenEdgeTypes = new Set();

    function applyFilters() {
        graphNodes.forEach((n, i) => {
            const vis = !hiddenNodeTypes.has(n.type);
            nodeEls[i].setAttribute('visibility', vis ? 'visible' : 'hidden');
            labelEls[i].setAttribute('visibility', vis ? 'visible' : 'hidden');
        });
        graphEdges.forEach((e, i) => {
            const sVis = !hiddenNodeTypes.has(graphNodes[e.source].type);
            const tVis = !hiddenNodeTypes.has(graphNodes[e.target].type);
            const edgeVis = !hiddenEdgeTypes.has(e.type);
            edgeEls[i].setAttribute('visibility', (sVis && tVis && edgeVis) ? 'visible' : 'hidden');
        });
    }

    window.toggleNodeFilter = function(cb) {
        if (cb.checked) hiddenNodeTypes.delete(cb.value);
        else hiddenNodeTypes.add(cb.value);
        applyFilters();
    };

    window.toggleEdgeFilter = function(cb) {
        if (cb.checked) hiddenEdgeTypes.delete(cb.value);
        else hiddenEdgeTypes.add(cb.value);
        applyFilters();
    };

    // --- Cycle Detection (Tarjan's SCC) ---
    function detectCycles() {
        const n = graphNodes.length;
        let index = 0;
        const stack = [];
        const onStack = new Array(n).fill(false);
        const indices = new Array(n).fill(-1);
        const lowlinks = new Array(n).fill(0);
        const sccs = [];

        // Build adjacency list from graphEdges
        const adj = Array.from({length: n}, () => []);
        graphEdges.forEach(e => { adj[e.source].push(e.target); });

        function strongconnect(v) {
            indices[v] = lowlinks[v] = index++;
            stack.push(v);
            onStack[v] = true;
            for (const w of adj[v]) {
                if (indices[w] === -1) {
                    strongconnect(w);
                    lowlinks[v] = Math.min(lowlinks[v], lowlinks[w]);
                } else if (onStack[w]) {
                    lowlinks[v] = Math.min(lowlinks[v], indices[w]);
                }
            }
            if (lowlinks[v] === indices[v]) {
                const scc = [];
                let w;
                do { w = stack.pop(); onStack[w] = false; scc.push(w); } while (w !== v);
                if (scc.length > 1) sccs.push(scc);
            }
        }

        for (let i = 0; i < n; i++) { if (indices[i] === -1) strongconnect(i); }
        return sccs;
    }

    const cycleSccs = detectCycles();

    // Build cycle membership: nodeIndex -> sccIndex, and mark cycle edges
    const nodeScc = {};
    cycleSccs.forEach((scc, si) => { scc.forEach(ni => { nodeScc[ni] = si; }); });

    const cycleEdgeSet = new Set();
    graphEdges.forEach((e, i) => {
        if (nodeScc[e.source] !== undefined && nodeScc[e.source] === nodeScc[e.target]) {
            cycleEdgeSet.add(i);
        }
    });

    // Apply cycle highlighting
    for (const ni in nodeScc) {
        nodeEls[ni].classList.add('cycle-node');
        nodeEls[ni].setAttribute('data-cycle-scc', nodeScc[ni]);
    }
    cycleEdgeSet.forEach(ei => {
        edgeEls[ei].setAttribute('data-cycle', 'true');
        edgeEls[ei].setAttribute('stroke', '#e94560');
        edgeEls[ei].setAttribute('stroke-opacity', '0.8');
    });

    // Expose cycle data globally for the warning banner
    window._cycleSccs = cycleSccs;
    window._cycleNodeScc = nodeScc;
    window._cycleEdgeSet = cycleEdgeSet;

    // --- Cycle filter toggle ---
    let cycleFilterActive = false;
    window.toggleCycleFilter = function(cb) {
        cycleFilterActive = cb.checked;
        graphNodes.forEach((n, i) => {
            if (nodeEls[i].getAttribute('visibility') === 'hidden') return;
            const inCycle = nodeScc[i] !== undefined;
            if (cycleFilterActive && !inCycle) {
                nodeEls[i].setAttribute('opacity', '0.1');
                labelEls[i].setAttribute('opacity', '0.1');
            } else {
                nodeEls[i].setAttribute('opacity', '1');
                labelEls[i].setAttribute('opacity', '1');
            }
        });
        graphEdges.forEach((e, i) => {
            if (edgeEls[i].getAttribute('visibility') === 'hidden') return;
            const inCycle = cycleEdgeSet.has(i);
            if (cycleFilterActive && !inCycle) {
                edgeEls[i].setAttribute('stroke-opacity', '0.05');
            } else {
                edgeEls[i].setAttribute('stroke-opacity', inCycle ? '0.8' : '0.4');
            }
        });
    };

    // Highlight a specific SCC (called from warning banner)
    window.highlightCycle = function(sccIdx) {
        graphNodes.forEach((n, i) => {
            if (nodeEls[i].getAttribute('visibility') === 'hidden') return;
            const match = nodeScc[i] === sccIdx;
            nodeEls[i].setAttribute('opacity', match ? '1' : '0.1');
            labelEls[i].setAttribute('opacity', match ? '1' : '0.1');
        });
        graphEdges.forEach((e, i) => {
            if (edgeEls[i].getAttribute('visibility') === 'hidden') return;
            const match = cycleEdgeSet.has(i) && nodeScc[e.source] === sccIdx;
            edgeEls[i].setAttribute('stroke-opacity', match ? '1' : '0.05');
            if (match) edgeEls[i].setAttribute('stroke-width', '3');
        });
        // Auto-restore after 5 seconds
        setTimeout(() => {
            graphNodes.forEach((n, i) => {
                if (nodeEls[i].getAttribute('visibility') === 'hidden') return;
                nodeEls[i].setAttribute('opacity', '1');
                labelEls[i].setAttribute('opacity', '1');
            });
            graphEdges.forEach((e, i) => {
                if (edgeEls[i].getAttribute('visibility') === 'hidden') return;
                edgeEls[i].setAttribute('stroke-opacity', cycleEdgeSet.has(i) ? '0.8' : '0.4');
                edgeEls[i].setAttribute('stroke-width', '1.5');
            });
        }, 5000);
    };

    // Populate the cycle warning banner
    const cycleWarning = document.getElementById('cycle-warning');
    if (cycleWarning && cycleSccs.length > 0) {
        const totalNodes = new Set();
        cycleSccs.forEach(scc => scc.forEach(ni => totalNodes.add(ni)));
        let html = '<div class="cycle-warning">';
        html += '<strong>⚠ ' + cycleSccs.length + ' Circular Dependenc' + (cycleSccs.length === 1 ? 'y' : 'ies') + ' Detected</strong>';
        html += ' (' + totalNodes.size + ' object' + (totalNodes.size === 1 ? '' : 's') + ' involved)';
        html += '<details><summary>Show cycle details</summary><ol>';
        cycleSccs.forEach((scc, si) => {
            const chain = scc.map(ni => graphNodes[ni].id);
            chain.push(graphNodes[scc[0]].id); // close the loop
            html += '<li><a class="cycle-chain" href="#dependencies" onclick="highlightCycle(' + si + '); return false;">';
            html += chain.join(' → ');
            html += '</a></li>';
        });
        html += '</ol></details></div>';
        cycleWarning.innerHTML = html;
        cycleWarning.style.display = 'block';
    }
})();
""";
    }

    private void BuildErdSection(StringBuilder sb, AnalysisResult result)
    {
        var schema = result.Schema!;
        var fkCount = schema.Tables.Sum(t => t.ForeignKeys.Count);
        var depCount = result.Relationships?.ViewDependencies.Count ?? 0;

        sb.AppendLine("<section id=\"erd\">");
        sb.AppendLine("<h2>Entity Relationship Diagram</h2>");
        sb.AppendLine($"<p class=\"meta\">{schema.Tables.Count} tables, {schema.Views.Count} views, {schema.StoredProcedures.Count} procedures, {schema.Functions.Count} functions, {fkCount} FK constraints, {depCount} dependencies. Scroll to zoom. Drag to pan/rearrange.</p>");

        // Filters
        sb.AppendLine("<div class=\"graph-filters\">");
        sb.AppendLine("<span class=\"meta\">Show:</span>");
        sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#e94560\"><input type=\"checkbox\" value=\"table\" checked onchange=\"toggleErdFilter(this)\"><span>Tables ({schema.Tables.Count})</span></label>");
        sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#4ecca3\"><input type=\"checkbox\" value=\"view\" checked onchange=\"toggleErdFilter(this)\"><span>Views ({schema.Views.Count})</span></label>");
        if (schema.StoredProcedures.Count > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#f0a500\"><input type=\"checkbox\" value=\"procedure\" checked onchange=\"toggleErdFilter(this)\"><span>Procedures ({schema.StoredProcedures.Count})</span></label>");
        if (schema.Functions.Count > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#bb86fc\"><input type=\"checkbox\" value=\"function\" checked onchange=\"toggleErdFilter(this)\"><span>Functions ({schema.Functions.Count})</span></label>");
        if (schema.Triggers.Count > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#ff7043\"><input type=\"checkbox\" value=\"trigger\" checked onchange=\"toggleErdFilter(this)\"><span>Triggers ({schema.Triggers.Count})</span></label>");
        if (schema.Synonyms.Count > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#78909c\"><input type=\"checkbox\" value=\"synonym\" checked onchange=\"toggleErdFilter(this)\"><span>Synonyms ({schema.Synonyms.Count})</span></label>");
        sb.AppendLine("</div>");

        sb.AppendLine("<div id=\"erd-container\"><svg id=\"erd-svg\"></svg></div>");
        sb.AppendLine("</section>");
    }

    private void BuildLineageSection(StringBuilder sb, AnalysisResult result)
    {
        var deps = result.Relationships!.Dependencies;

        sb.AppendLine("<section id=\"lineage\">");
        sb.AppendLine("<h2>Data Lineage</h2>");
        sb.AppendLine("<p class=\"meta\">Select an object to trace its complete upstream (data sources) and downstream (consumers) flow. Hover nodes to highlight paths.</p>");

        // Search + action controls
        sb.AppendLine("<div class=\"lineage-controls\">");
        sb.AppendLine("<input type=\"text\" id=\"lineage-search\" list=\"lineage-objects\" placeholder=\"Search for an object...\">");
        sb.AppendLine("<datalist id=\"lineage-objects\"></datalist>");
        sb.AppendLine("<button id=\"lineage-show\">Show Lineage</button>");
        sb.AppendLine("<button id=\"lineage-clear\">Clear</button>");
        sb.AppendLine("</div>");

        sb.AppendLine("<div id=\"lineage-container\">");
        sb.AppendLine("<div id=\"lineage-empty\" class=\"lineage-empty\">Select an object above and click &ldquo;Show Lineage&rdquo; to visualize its data flow.</div>");
        sb.AppendLine("<svg id=\"lineage-svg\" style=\"display:none\"></svg>");
        sb.AppendLine("</div>");
        sb.AppendLine("</section>");
    }

    private string GetErdJs(AnalysisResult result)
    {
        var schema = result.Schema!;

        string ColType(ColumnInfo c)
        {
            if (c.MaxLength.HasValue)
                return $"{c.DataType}({(c.MaxLength == -1 ? "MAX" : c.MaxLength.ToString())})";
            if (c.Precision.HasValue)
                return $"{c.DataType}({c.Precision},{c.Scale})";
            return c.DataType;
        }

        // Build ERD boxes for all object types
        var boxes = new List<object>();

        // Tables
        foreach (var t in schema.Tables)
        {
            var cols = t.Columns.Select(c =>
            {
                var fk = t.ForeignKeys.FirstOrDefault(f =>
                    string.Equals(f.FromColumn, c.Name, StringComparison.OrdinalIgnoreCase));
                return new { name = c.Name, type = ColType(c), pk = c.IsPrimaryKey, fk = fk is not null, nullable = c.IsNullable };
            }).ToList<object>();
            boxes.Add(new { fullName = t.FullName, objType = "table", label = t.FullName, columns = cols, subtitle = "" });
        }

        // Views (with columns)
        foreach (var v in schema.Views)
        {
            var cols = v.Columns.Select(c =>
                new { name = c.Name, type = ColType(c), pk = false, fk = false, nullable = c.IsNullable }
            ).ToList<object>();
            boxes.Add(new { fullName = v.FullName, objType = "view", label = v.FullName, columns = cols, subtitle = "VIEW" });
        }

        // Stored Procedures (no columns, just name)
        foreach (var sp in schema.StoredProcedures)
        {
            var modified = sp.LastModified?.ToString("yyyy-MM-dd") ?? "";
            boxes.Add(new { fullName = sp.FullName, objType = "procedure", label = sp.FullName, columns = new List<object>(), subtitle = modified });
        }

        // Functions
        foreach (var fn in schema.Functions)
        {
            var modified = fn.LastModified?.ToString("yyyy-MM-dd") ?? "";
            boxes.Add(new { fullName = fn.FullName, objType = "function", label = fn.FullName, columns = new List<object>(), subtitle = fn.FunctionType });
        }

        // Triggers
        foreach (var tr in schema.Triggers)
        {
            boxes.Add(new { fullName = tr.FullName, objType = "trigger", label = tr.FullName, columns = new List<object>(), subtitle = $"{tr.TriggerType} {tr.TriggerEvents}" });
        }

        // Synonyms
        foreach (var syn in schema.Synonyms)
        {
            boxes.Add(new { fullName = syn.FullName, objType = "synonym", label = syn.FullName, columns = new List<object>(), subtitle = syn.BaseObjectName });
        }

        // Build FK edges
        var fks = new List<object>();
        foreach (var t in schema.Tables)
        {
            foreach (var fk in t.ForeignKeys)
            {
                fks.Add(new
                {
                    name = fk.Name,
                    fromTable = $"{fk.FromSchema}.{fk.FromTable}",
                    fromCol = fk.FromColumn,
                    toTable = $"{fk.ToSchema}.{fk.ToTable}",
                    toCol = fk.ToColumn,
                    deleteRule = fk.DeleteRule,
                    updateRule = fk.UpdateRule,
                    edgeType = "fk"
                });
            }
        }

        // Build object dependency edges
        var deps = new List<object>();
        if (result.Relationships?.ViewDependencies is not null)
        {
            var seen = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
            foreach (var vd in result.Relationships.ViewDependencies)
            {
                if (vd.IsCrossDatabase) continue;
                var key = $"{vd.FromSchema}.{vd.FromName}->{vd.ToSchema}.{vd.ToName}";
                if (!seen.Add(key)) continue;
                deps.Add(new
                {
                    fromObj = $"{vd.FromSchema}.{vd.FromName}",
                    fromType = vd.FromType,
                    toObj = $"{vd.ToSchema}.{vd.ToName}",
                    toType = vd.ToType,
                    edgeType = vd.FromType.ToLowerInvariant()
                });
            }
        }

        var boxesJson = JsonSerializer.Serialize(boxes);
        var fksJson = JsonSerializer.Serialize(fks);
        var depsJson = JsonSerializer.Serialize(deps);

        return $$"""
const erdBoxes = {{boxesJson}};
const erdFks = {{fksJson}};
const erdDeps = {{depsJson}};

(function() {
    const svg = document.getElementById('erd-svg');
    const container = document.getElementById('erd-container');
    const W = container.clientWidth || 1400;
    const COL_W = 230, HDR_H = 32, ROW_H = 22, PAD = 8, GAP = 40, SUB_H = 18;
    const typeColors = { table:'#0f3460', view:'#1a5c45', procedure:'#5c3d00', function:'#3d1f6d', trigger:'#5c2310', synonym:'#37474f' };
    const titleColors = { table:'#e94560', view:'#4ecca3', procedure:'#f0a500', function:'#bb86fc', trigger:'#ff7043', synonym:'#78909c' };
    const edgeColors = { fk:'#4fc3f7', view:'#4ecca3', procedure:'#f0a500', function:'#bb86fc', trigger:'#ff7043', synonym:'#78909c' };

    // Compute box sizes
    erdBoxes.forEach(b => {
        b.w = COL_W;
        const rows = b.columns.length;
        const sub = b.subtitle ? SUB_H : 0;
        b.h = rows > 0 ? HDR_H + rows * ROW_H + PAD : HDR_H + sub + PAD + 4;
    });

    // Grid layout — group by type
    const typeOrder = ['table','view','procedure','function','trigger','synonym'];
    const sorted = [...erdBoxes.keys()].sort((a,b) => {
        const ta = typeOrder.indexOf(erdBoxes[a].objType), tb = typeOrder.indexOf(erdBoxes[b].objType);
        return ta - tb || a - b;
    });
    const gridCols = Math.max(1, Math.floor((W - GAP) / (COL_W + GAP)));
    let maxRowH = 0, cx = GAP, cy = GAP;
    sorted.forEach((idx, si) => {
        const b = erdBoxes[idx];
        if (cx + b.w > W - GAP) { cx = GAP; cy += maxRowH + GAP; maxRowH = 0; }
        b.x = cx; b.y = cy;
        maxRowH = Math.max(maxRowH, b.h);
        cx += b.w + GAP;
    });

    const totalH = Math.max(800, cy + maxRowH + GAP * 2);
    svg.setAttribute('width', W);
    svg.setAttribute('height', totalH);

    let vb = { x: 0, y: 0, w: W, h: totalH };
    const updateVB = () => svg.setAttribute('viewBox', `${vb.x} ${vb.y} ${vb.w} ${vb.h}`);
    updateVB();
    function s2w(sx, sy) { const r = svg.getBoundingClientRect(); return { x: vb.x + (sx-r.left)/r.width*vb.w, y: vb.y + (sy-r.top)/r.height*vb.h }; }

    // Defs
    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    // Crow's foot "one"
    const mOne = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
    mOne.setAttribute('id','erd-one'); mOne.setAttribute('viewBox','0 0 10 10');
    mOne.setAttribute('refX','10'); mOne.setAttribute('refY','5');
    mOne.setAttribute('markerWidth','8'); mOne.setAttribute('markerHeight','8'); mOne.setAttribute('orient','auto');
    const op = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    op.setAttribute('d','M 10 0 L 10 10 M 6 0 L 6 10');
    op.setAttribute('stroke','#4fc3f7'); op.setAttribute('fill','none'); op.setAttribute('stroke-width','1.5');
    mOne.appendChild(op); defs.appendChild(mOne);
    // Crow's foot "many"
    const mMany = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
    mMany.setAttribute('id','erd-many'); mMany.setAttribute('viewBox','0 0 12 12');
    mMany.setAttribute('refX','0'); mMany.setAttribute('refY','6');
    mMany.setAttribute('markerWidth','10'); mMany.setAttribute('markerHeight','10'); mMany.setAttribute('orient','auto');
    const mp = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    mp.setAttribute('d','M 0 6 L 12 0 M 0 6 L 12 6 M 0 6 L 12 12');
    mp.setAttribute('stroke','#4fc3f7'); mp.setAttribute('fill','none'); mp.setAttribute('stroke-width','1.5');
    mMany.appendChild(mp); defs.appendChild(mMany);
    // Dep arrow
    const mArr = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
    mArr.setAttribute('id','erd-arrow'); mArr.setAttribute('viewBox','0 0 10 10');
    mArr.setAttribute('refX','10'); mArr.setAttribute('refY','5');
    mArr.setAttribute('markerWidth','6'); mArr.setAttribute('markerHeight','6'); mArr.setAttribute('orient','auto');
    const ap = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    ap.setAttribute('d','M 0 0 L 10 5 L 0 10 z'); ap.setAttribute('fill','#888');
    mArr.appendChild(ap); defs.appendChild(mArr);
    svg.appendChild(defs);

    const lineGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const boxGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    svg.appendChild(lineGroup); svg.appendChild(boxGroup);

    const tip = document.createElement('div'); tip.className = 'graph-tooltip'; container.appendChild(tip);
    const ctrl = document.createElement('div'); ctrl.className = 'graph-controls';
    ctrl.innerHTML = '<button id="erd-zi" title="Zoom in">+</button><button id="erd-zo" title="Zoom out">&minus;</button><button id="erd-zr" title="Fit all">&#8634;</button><button id="erd-reorder" title="Auto-layout (connection-aware)">&#9638;</button><button id="erd-fs" title="Fullscreen">&#x26F6;</button>';
    container.appendChild(ctrl);

    const boxIdx = {};
    erdBoxes.forEach((b, i) => boxIdx[b.fullName] = i);

    // Draw boxes
    const boxGroups = erdBoxes.map((b, bi) => {
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.style.cursor = 'grab';
        b._g = g;

        const hdrColor = typeColors[b.objType] || '#0f3460';
        const tColor = titleColors[b.objType] || '#e94560';

        // Background
        const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        bg.setAttribute('width', b.w); bg.setAttribute('height', b.h);
        bg.setAttribute('fill', '#16213e'); bg.setAttribute('stroke', hdrColor);
        bg.setAttribute('stroke-width', '2'); bg.setAttribute('rx', '6');
        g.appendChild(bg);

        // Header bar
        const hdr = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        hdr.setAttribute('width', b.w); hdr.setAttribute('height', HDR_H);
        hdr.setAttribute('fill', hdrColor); hdr.setAttribute('rx', '6');
        g.appendChild(hdr);
        const hdr2 = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        hdr2.setAttribute('y', HDR_H - 6); hdr2.setAttribute('width', b.w); hdr2.setAttribute('height', 6);
        hdr2.setAttribute('fill', hdrColor);
        g.appendChild(hdr2);

        // Type badge (small text in top-right)
        if (b.objType !== 'table') {
            const badge = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            badge.textContent = b.objType.toUpperCase();
            badge.setAttribute('x', b.w - 6); badge.setAttribute('y', 12);
            badge.setAttribute('text-anchor', 'end');
            badge.setAttribute('fill', tColor); badge.setAttribute('font-size', '8');
            badge.setAttribute('opacity', '0.7');
            g.appendChild(badge);
        }

        // Title
        const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        title.textContent = b.label;
        title.setAttribute('x', b.w / 2); title.setAttribute('y', b.objType !== 'table' ? HDR_H / 2 + 8 : HDR_H / 2 + 5);
        title.setAttribute('text-anchor', 'middle');
        title.setAttribute('fill', tColor); title.setAttribute('font-weight', 'bold');
        title.setAttribute('font-size', '11');
        g.appendChild(title);

        if (b.columns.length > 0) {
            // Columns (tables & views)
            b.columns.forEach((c, ci) => {
                const ry = HDR_H + ci * ROW_H + ROW_H / 2 + 5;
                let icon = '';
                if (c.pk && c.fk) icon = 'PF';
                else if (c.pk) icon = 'PK';
                else if (c.fk) icon = 'FK';
                if (icon) {
                    const ic = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    ic.textContent = icon;
                    ic.setAttribute('x', 8); ic.setAttribute('y', ry);
                    ic.setAttribute('fill', c.pk ? '#4ecca3' : '#f0a500');
                    ic.setAttribute('font-size', '9'); ic.setAttribute('font-weight', 'bold');
                    g.appendChild(ic);
                }
                const nm = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                nm.textContent = c.name;
                nm.setAttribute('x', 32); nm.setAttribute('y', ry);
                nm.setAttribute('fill', c.pk ? '#4ecca3' : c.fk ? '#f0a500' : '#e0e0e0');
                nm.setAttribute('font-size', '11');
                if (c.pk) nm.setAttribute('font-weight', 'bold');
                g.appendChild(nm);
                const tp = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                tp.textContent = c.type + (c.nullable ? '' : ' *');
                tp.setAttribute('x', b.w - 8); tp.setAttribute('y', ry);
                tp.setAttribute('text-anchor', 'end');
                tp.setAttribute('fill', '#888'); tp.setAttribute('font-size', '10');
                g.appendChild(tp);
            });
        } else if (b.subtitle) {
            // Subtitle for procs/functions/triggers/synonyms
            const sub = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            sub.textContent = b.subtitle.length > 35 ? b.subtitle.substring(0, 35) + '...' : b.subtitle;
            sub.setAttribute('x', b.w / 2); sub.setAttribute('y', HDR_H + SUB_H / 2 + 5);
            sub.setAttribute('text-anchor', 'middle');
            sub.setAttribute('fill', '#888'); sub.setAttribute('font-size', '10');
            g.appendChild(sub);
        }

        g.setAttribute('transform', `translate(${b.x},${b.y})`);
        boxGroup.appendChild(g);
        return g;
    });

    function colY(box, colName) {
        const ci = box.columns.findIndex(c => c.name.toLowerCase() === colName.toLowerCase());
        if (ci < 0) return box.y + box.h / 2;
        return box.y + HDR_H + ci * ROW_H + ROW_H / 2;
    }
    function midY(box) { return box.y + box.h / 2; }

    function bezier(fromB, fy, toB, ty) {
        const fcx = fromB.x + fromB.w / 2, tcx = toB.x + toB.w / 2;
        let fx, tx, cx1, cx2;
        if (fcx < tcx) { fx = fromB.x + fromB.w; tx = toB.x; }
        else if (fcx > tcx) { fx = fromB.x; tx = toB.x + toB.w; }
        else { fx = fromB.x + fromB.w; tx = toB.x + toB.w; }
        const gap = Math.abs(tx - fx);
        cx1 = fx + (fx < tx ? 1 : -1) * Math.max(30, gap * 0.4);
        cx2 = tx + (tx < fx ? 1 : -1) * Math.max(30, gap * 0.4);
        return `M ${fx} ${fy} C ${cx1} ${fy}, ${cx2} ${ty}, ${tx} ${ty}`;
    }

    // Draw FK lines
    const allLines = [];
    erdFks.forEach(fk => {
        const fi = boxIdx[fk.fromTable], ti = boxIdx[fk.toTable];
        if (fi === undefined || ti === undefined) return;
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('fill', 'none'); path.setAttribute('stroke', '#4fc3f7');
        path.setAttribute('stroke-width', '1.5'); path.setAttribute('stroke-opacity', '0.6');
        path.setAttribute('marker-start', 'url(#erd-many)'); path.setAttribute('marker-end', 'url(#erd-one)');
        path.style.cursor = 'pointer';
        lineGroup.appendChild(path);
        path.addEventListener('mouseenter', (ev) => {
            tip.innerHTML = `<strong>FK: ${fk.name}</strong><br>${fk.fromTable}.${fk.fromCol} &rarr; ${fk.toTable}.${fk.toCol}<br>Delete: ${fk.deleteRule} | Update: ${fk.updateRule}`;
            tip.style.display = 'block'; const cr = container.getBoundingClientRect();
            tip.style.left = (ev.clientX-cr.left+15)+'px'; tip.style.top = (ev.clientY-cr.top-10)+'px';
            path.setAttribute('stroke-opacity','1'); path.setAttribute('stroke-width','3');
        });
        path.addEventListener('mousemove', (ev) => { const cr = container.getBoundingClientRect(); tip.style.left=(ev.clientX-cr.left+15)+'px'; tip.style.top=(ev.clientY-cr.top-10)+'px'; });
        path.addEventListener('mouseleave', () => { tip.style.display='none'; path.setAttribute('stroke-opacity','0.6'); path.setAttribute('stroke-width','1.5'); });
        allLines.push({ el: path, kind: 'fk', fromIdx: fi, toIdx: ti, fromCol: fk.fromCol, toCol: fk.toCol });
    });

    // Draw dependency lines
    erdDeps.forEach(dep => {
        const fi = boxIdx[dep.fromObj], ti = boxIdx[dep.toObj];
        if (fi === undefined || ti === undefined) return;
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        const color = edgeColors[dep.edgeType] || '#888';
        path.setAttribute('fill', 'none'); path.setAttribute('stroke', color);
        path.setAttribute('stroke-width', '1.2'); path.setAttribute('stroke-opacity', '0.5');
        path.setAttribute('stroke-dasharray', '6,3');
        path.setAttribute('marker-end', 'url(#erd-arrow)');
        path.style.cursor = 'pointer';
        lineGroup.appendChild(path);
        path.addEventListener('mouseenter', (ev) => {
            tip.innerHTML = `<strong>${dep.fromType} &rarr; ${dep.toType}</strong><br>${dep.fromObj} &rarr; ${dep.toObj}`;
            tip.style.display = 'block'; const cr = container.getBoundingClientRect();
            tip.style.left = (ev.clientX-cr.left+15)+'px'; tip.style.top = (ev.clientY-cr.top-10)+'px';
            path.setAttribute('stroke-opacity','1'); path.setAttribute('stroke-width','2.5');
        });
        path.addEventListener('mousemove', (ev) => { const cr = container.getBoundingClientRect(); tip.style.left=(ev.clientX-cr.left+15)+'px'; tip.style.top=(ev.clientY-cr.top-10)+'px'; });
        path.addEventListener('mouseleave', () => { tip.style.display='none'; path.setAttribute('stroke-opacity','0.5'); path.setAttribute('stroke-width','1.2'); });
        allLines.push({ el: path, kind: 'dep', edgeType: dep.edgeType, fromIdx: fi, toIdx: ti });
    });

    function updateLines() {
        allLines.forEach(ln => {
            const fromB = erdBoxes[ln.fromIdx], toB = erdBoxes[ln.toIdx];
            const fy = ln.fromCol ? colY(fromB, ln.fromCol) : midY(fromB);
            const ty = ln.toCol ? colY(toB, ln.toCol) : midY(toB);
            ln.el.setAttribute('d', bezier(fromB, fy, toB, ty));
        });
    }
    updateLines();

    // --- Drag & Pan ---
    let dragBox = null, dragOff = {x:0,y:0};
    let isPanning = false, panStart = {x:0,y:0}, vbStart = {x:0,y:0};

    svg.addEventListener('mousedown', (ev) => {
        const p = s2w(ev.clientX, ev.clientY);
        for (let i = 0; i < erdBoxes.length; i++) {
            const b = erdBoxes[i];
            if (b._g.getAttribute('visibility') === 'hidden') continue;
            if (p.x >= b.x && p.x <= b.x + b.w && p.y >= b.y && p.y <= b.y + b.h) {
                dragBox = i; dragOff = {x: p.x - b.x, y: p.y - b.y};
                svg.style.cursor = 'grabbing'; return;
            }
        }
        isPanning = true; panStart = {x:ev.clientX,y:ev.clientY}; vbStart = {x:vb.x,y:vb.y};
        svg.style.cursor = 'move';
    });
    svg.addEventListener('mousemove', (ev) => {
        if (dragBox !== null) {
            const p = s2w(ev.clientX, ev.clientY);
            erdBoxes[dragBox].x = p.x - dragOff.x; erdBoxes[dragBox].y = p.y - dragOff.y;
            boxGroups[dragBox].setAttribute('transform', `translate(${erdBoxes[dragBox].x},${erdBoxes[dragBox].y})`);
            updateLines();
        } else if (isPanning) {
            const r = svg.getBoundingClientRect();
            vb.x = vbStart.x - (ev.clientX-panStart.x)/r.width*vb.w;
            vb.y = vbStart.y - (ev.clientY-panStart.y)/r.height*vb.h;
            updateVB();
        }
    });
    svg.addEventListener('mouseup', () => { dragBox=null; isPanning=false; svg.style.cursor='default'; });
    svg.addEventListener('mouseleave', () => { dragBox=null; isPanning=false; svg.style.cursor='default'; });

    // --- Zoom ---
    function zoomBy(f,cx,cy) { const nw=vb.w/f,nh=vb.h/f; vb.x=cx-(cx-vb.x)/f; vb.y=cy-(cy-vb.y)/f; vb.w=nw;vb.h=nh; updateVB(); }
    svg.addEventListener('wheel', (ev) => { ev.preventDefault(); const p=s2w(ev.clientX,ev.clientY); zoomBy(ev.deltaY<0?1.15:1/1.15,p.x,p.y); }, {passive:false});
    document.getElementById('erd-zi').addEventListener('click', () => { zoomBy(1.3,vb.x+vb.w/2,vb.y+vb.h/2); });
    document.getElementById('erd-zo').addEventListener('click', () => { zoomBy(1/1.3,vb.x+vb.w/2,vb.y+vb.h/2); });
    document.getElementById('erd-zr').addEventListener('click', () => { fitAll(); });

    function fitAll() {
        let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
        erdBoxes.forEach(b => {
            if (b._g.getAttribute('visibility') === 'hidden') return;
            minX=Math.min(minX,b.x); minY=Math.min(minY,b.y);
            maxX=Math.max(maxX,b.x+b.w); maxY=Math.max(maxY,b.y+b.h);
        });
        if (minX===Infinity) { vb={x:0,y:0,w:W,h:totalH}; updateVB(); return; }
        const pad=40;
        vb={x:minX-pad, y:minY-pad, w:maxX-minX+pad*2, h:maxY-minY+pad*2};
        updateVB();
    }

    // --- Auto-layout (connection-aware force-directed) ---
    document.getElementById('erd-reorder').addEventListener('click', () => {
        const cw = container.clientWidth || 1400;
        const ch = container.clientHeight || 800;
        const visible = [];
        erdBoxes.forEach((b,i) => { if (b._g.getAttribute('visibility') !== 'hidden') visible.push(i); });
        if (visible.length === 0) return;

        // Build adjacency from lines
        const adj = new Map();
        visible.forEach(i => adj.set(i, new Set()));
        allLines.forEach(ln => {
            if (adj.has(ln.fromIdx) && adj.has(ln.toIdx)) {
                adj.get(ln.fromIdx).add(ln.toIdx);
                adj.get(ln.toIdx).add(ln.fromIdx);
            }
        });

        // Init positions — spread across available area
        const area = Math.max(cw, ch) * Math.sqrt(visible.length) * 0.7;
        const cx0 = area / 2, cy0 = area / 2;
        visible.forEach((idx, i) => {
            const angle = (2 * Math.PI * i) / visible.length;
            const radius = area * 0.35;
            erdBoxes[idx].x = cx0 + Math.cos(angle) * radius;
            erdBoxes[idx].y = cy0 + Math.sin(angle) * radius;
        });

        // Force-directed simulation
        const ITERATIONS = 200;
        const REPULSION = 80000;
        const ATTRACTION = 0.003;
        const DAMPING = 0.9;
        const MIN_DIST = 50;

        const vel = {};
        visible.forEach(i => { vel[i] = {x:0, y:0}; });

        for (let iter = 0; iter < ITERATIONS; iter++) {
            const temp = 1 - iter / ITERATIONS; // cooling
            const forces = {};
            visible.forEach(i => { forces[i] = {x:0, y:0}; });

            // Repulsion between all pairs
            for (let ai = 0; ai < visible.length; ai++) {
                for (let bi = ai+1; bi < visible.length; bi++) {
                    const a = visible[ai], b = visible[bi];
                    const ba = erdBoxes[a], bb = erdBoxes[b];
                    let dx = (ba.x + ba.w/2) - (bb.x + bb.w/2);
                    let dy = (ba.y + ba.h/2) - (bb.y + bb.h/2);
                    const dist = Math.max(MIN_DIST, Math.sqrt(dx*dx + dy*dy));
                    const f = REPULSION / (dist * dist);
                    const fx = (dx/dist) * f, fy = (dy/dist) * f;
                    forces[a].x += fx; forces[a].y += fy;
                    forces[b].x -= fx; forces[b].y -= fy;
                }
            }

            // Attraction along edges
            allLines.forEach(ln => {
                if (!adj.has(ln.fromIdx) || !adj.has(ln.toIdx)) return;
                const ba = erdBoxes[ln.fromIdx], bb = erdBoxes[ln.toIdx];
                const dx = (bb.x + bb.w/2) - (ba.x + ba.w/2);
                const dy = (bb.y + bb.h/2) - (ba.y + ba.h/2);
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < 1) return;
                const idealDist = 300;
                const f = ATTRACTION * (dist - idealDist);
                const fx = (dx/dist) * f, fy = (dy/dist) * f;
                forces[ln.fromIdx].x += fx; forces[ln.fromIdx].y += fy;
                forces[ln.toIdx].x -= fx; forces[ln.toIdx].y -= fy;
            });

            // Apply forces with damping and cooling
            visible.forEach(i => {
                vel[i].x = (vel[i].x + forces[i].x) * DAMPING * temp;
                vel[i].y = (vel[i].y + forces[i].y) * DAMPING * temp;
                const maxV = 50 * temp;
                const speed = Math.sqrt(vel[i].x*vel[i].x + vel[i].y*vel[i].y);
                if (speed > maxV) { vel[i].x *= maxV/speed; vel[i].y *= maxV/speed; }
                erdBoxes[i].x += vel[i].x;
                erdBoxes[i].y += vel[i].y;
            });

            // Prevent box overlap — push apart
            const OVERLAP_GAP = GAP;
            for (let ai = 0; ai < visible.length; ai++) {
                for (let bi = ai+1; bi < visible.length; bi++) {
                    const a = visible[ai], b = visible[bi];
                    const ba = erdBoxes[a], bb = erdBoxes[b];
                    const ox = (ba.w/2 + bb.w/2 + OVERLAP_GAP) - Math.abs((ba.x+ba.w/2)-(bb.x+bb.w/2));
                    const oy = (ba.h/2 + bb.h/2 + OVERLAP_GAP) - Math.abs((ba.y+ba.h/2)-(bb.y+bb.h/2));
                    if (ox > 0 && oy > 0) {
                        if (ox < oy) {
                            const push = ox / 2 + 1;
                            if (ba.x < bb.x) { ba.x -= push; bb.x += push; }
                            else { ba.x += push; bb.x -= push; }
                        } else {
                            const push = oy / 2 + 1;
                            if (ba.y < bb.y) { ba.y -= push; bb.y += push; }
                            else { ba.y += push; bb.y -= push; }
                        }
                    }
                }
            }
        }

        // Shift so top-left is at GAP,GAP
        let minX=Infinity, minY=Infinity;
        visible.forEach(i => { minX=Math.min(minX,erdBoxes[i].x); minY=Math.min(minY,erdBoxes[i].y); });
        visible.forEach(i => { erdBoxes[i].x -= minX - GAP; erdBoxes[i].y -= minY - GAP; });

        // Update SVG
        visible.forEach(i => {
            boxGroups[i].setAttribute('transform', `translate(${erdBoxes[i].x},${erdBoxes[i].y})`);
        });
        updateLines();
        fitAll();
    });

    // --- Fullscreen ---
    const fsBtn = document.getElementById('erd-fs');
    fsBtn.addEventListener('click', () => {
        if (document.fullscreenElement) {
            document.exitFullscreen();
        } else {
            container.requestFullscreen().catch(() => {});
        }
    });
    document.addEventListener('fullscreenchange', () => {
        if (document.fullscreenElement === container) {
            container.style.height = '100vh';
            container.style.borderRadius = '0';
            svg.setAttribute('width', screen.width);
            svg.setAttribute('height', screen.height);
            fsBtn.textContent = '\u2716'; fsBtn.title = 'Exit fullscreen';
        } else {
            container.style.height = '';
            container.style.borderRadius = '';
            svg.setAttribute('width', container.clientWidth || W);
            svg.setAttribute('height', totalH);
            fsBtn.textContent = '\u26F6'; fsBtn.title = 'Fullscreen';
        }
        fitAll();
    });

    // --- Filtering ---
    const hiddenTypes = new Set();
    function applyErdFilters() {
        erdBoxes.forEach((b, i) => {
            const vis = !hiddenTypes.has(b.objType);
            boxGroups[i].setAttribute('visibility', vis ? 'visible' : 'hidden');
        });
        allLines.forEach(ln => {
            const sVis = !hiddenTypes.has(erdBoxes[ln.fromIdx].objType);
            const tVis = !hiddenTypes.has(erdBoxes[ln.toIdx].objType);
            ln.el.setAttribute('visibility', (sVis && tVis) ? 'visible' : 'hidden');
        });
    }
    window.toggleErdFilter = function(cb) {
        if (cb.checked) hiddenTypes.delete(cb.value); else hiddenTypes.add(cb.value);
        applyErdFilters();
    };
})();
""";
    }

    private string GetLineageJs(AnalysisResult result)
    {
        var deps = result.Relationships!.Dependencies;
        var fks = result.Relationships!.ExplicitRelationships;
        var viewDeps = result.Relationships!.ViewDependencies;

        // Build nodes: { id, type, dependsOn[], referencedBy[] }
        var nodes = deps.Select(d => new
        {
            id = d.FullName,
            type = d.ObjectType.ToLowerInvariant(),
            dependsOn = d.DependsOn,
            referencedBy = d.ReferencedBy
        }).ToList<object>();

        // Build edges: union of FK edges + object dependency edges
        var edgeSet = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        var edges = new List<object>();

        foreach (var fk in fks)
        {
            var from = $"{fk.FromSchema}.{fk.FromTable}";
            var to = $"{fk.ToSchema}.{fk.ToTable}";
            var key = $"{from}->{to}";
            if (!edgeSet.Add(key)) continue;
            edges.Add(new { from, to, edgeType = "fk", label = $"FK: {fk.Name}" });
        }

        foreach (var vd in viewDeps)
        {
            var from = $"{vd.FromSchema}.{vd.FromName}";
            var to = vd.ToFullName;
            var key = $"{from}->{to}";
            if (!edgeSet.Add(key)) continue;
            var label = vd.FromType.ToLowerInvariant() switch
            {
                "view" => "reads from",
                "procedure" => "calls",
                "function" => "calls",
                "trigger" => "triggered by",
                "synonym" => "alias for",
                "job" => "executes",
                _ => "depends on"
            };
            var edgeType = vd.IsCrossDatabase ? "external" : vd.FromType.ToLowerInvariant();
            edges.Add(new { from, to, edgeType, label });
        }

        var nodesJson = JsonSerializer.Serialize(nodes);
        var edgesJson = JsonSerializer.Serialize(edges);

        return $$"""
const lineageNodes = {{nodesJson}};
const lineageEdges = {{edgesJson}};

(function() {
    const svg = document.getElementById('lineage-svg');
    const container = document.getElementById('lineage-container');
    const emptyMsg = document.getElementById('lineage-empty');
    const searchInput = document.getElementById('lineage-search');
    const datalist = document.getElementById('lineage-objects');
    const W = container.clientWidth || 1400;
    const H = 700;

    // Constants
    const LAYER_W = 250, NODE_W = 180, NODE_H = 40, GAP = 20;
    const typeColors = { table:'#e94560', view:'#4ecca3', procedure:'#f0a500', function:'#bb86fc', trigger:'#ff7043', synonym:'#78909c', job:'#26a69a', external:'#ff6b6b' };
    const edgeColors = { fk:'#4fc3f7', view:'#4ecca3', procedure:'#f0a500', function:'#bb86fc', trigger:'#ff7043', synonym:'#78909c', job:'#26a69a', external:'#ff6b6b' };

    // Build lookup maps
    const nodeMap = {};
    lineageNodes.forEach(n => { nodeMap[n.id.toLowerCase()] = n; });

    // Cycle membership from dependency graph (shared via globals)
    const cycleNodeIds = new Set();
    const cycleNodePairs = new Set();
    if (window._cycleSccs) {
        window._cycleSccs.forEach(scc => {
            const ids = scc.map(ni => graphNodes[ni].id.toLowerCase());
            ids.forEach(id => cycleNodeIds.add(id));
            // Track pairs for edge coloring
            for (let a = 0; a < ids.length; a++)
                for (let b = 0; b < ids.length; b++)
                    if (a !== b) cycleNodePairs.add(ids[a] + '|' + ids[b]);
        });
    }

    // Populate datalist for autocomplete
    lineageNodes.forEach(n => {
        const opt = document.createElement('option');
        opt.value = n.id;
        datalist.appendChild(opt);
    });

    // Zoom/pan state
    let vb = { x: 0, y: 0, w: W, h: H };
    const updateVB = () => svg.setAttribute('viewBox', `${vb.x} ${vb.y} ${vb.w} ${vb.h}`);
    function s2w(sx, sy) { const r = svg.getBoundingClientRect(); return { x: vb.x + (sx-r.left)/r.width*vb.w, y: vb.y + (sy-r.top)/r.height*vb.h }; }

    // BFS to compute lineage layers
    function computeLineage(selectedId) {
        const sid = selectedId.toLowerCase();
        const node = nodeMap[sid];
        if (!node) return null;

        const layers = {}; // layer number -> [nodeId, ...]
        const nodeLayer = {}; // nodeId -> layer number
        layers[0] = [node.id];
        nodeLayer[sid] = 0;

        // Upstream BFS (follow dependsOn = sources)
        let queue = [...(node.dependsOn || [])];
        let nextLayer = -1;
        let visited = new Set([sid]);
        while (queue.length > 0) {
            const nextQueue = [];
            const layerNodes = [];
            for (const depId of queue) {
                const did = depId.toLowerCase();
                if (visited.has(did)) continue;
                visited.add(did);
                layerNodes.push(depId);
                nodeLayer[did] = nextLayer;
                const dn = nodeMap[did];
                if (dn && dn.dependsOn) {
                    for (const up of dn.dependsOn) {
                        if (!visited.has(up.toLowerCase())) nextQueue.push(up);
                    }
                }
            }
            if (layerNodes.length > 0) layers[nextLayer] = layerNodes;
            queue = nextQueue;
            nextLayer--;
        }

        // Downstream BFS (follow referencedBy = consumers)
        queue = [...(node.referencedBy || [])];
        nextLayer = 1;
        while (queue.length > 0) {
            const nextQueue = [];
            const layerNodes = [];
            for (const refId of queue) {
                const rid = refId.toLowerCase();
                if (visited.has(rid)) continue;
                visited.add(rid);
                layerNodes.push(refId);
                nodeLayer[rid] = nextLayer;
                const rn = nodeMap[rid];
                if (rn && rn.referencedBy) {
                    for (const down of rn.referencedBy) {
                        if (!visited.has(down.toLowerCase())) nextQueue.push(down);
                    }
                }
            }
            if (layerNodes.length > 0) layers[nextLayer] = layerNodes;
            queue = nextQueue;
            nextLayer++;
        }

        return { layers, nodeLayer, selectedId: node.id };
    }

    // Layout: assign x/y positions
    function layoutLineage(lineageData) {
        const { layers, selectedId } = lineageData;
        const layerKeys = Object.keys(layers).map(Number).sort((a, b) => a - b);
        const positions = {}; // nodeId -> { x, y, layer }

        const totalLayers = layerKeys.length;
        const totalW = totalLayers * LAYER_W;
        const offsetX = Math.max(40, (W - totalW) / 2);

        layerKeys.forEach((layerNum, li) => {
            const nodesInLayer = layers[layerNum];
            const totalH = nodesInLayer.length * (NODE_H + GAP) - GAP;
            const offsetY = Math.max(60, (H - totalH) / 2);

            nodesInLayer.forEach((nid, ni) => {
                positions[nid.toLowerCase()] = {
                    x: offsetX + li * LAYER_W,
                    y: offsetY + ni * (NODE_H + GAP),
                    layer: layerNum
                };
            });
        });

        return { positions, layerKeys };
    }

    // Collect edges relevant to the lineage
    function getLineageEdges(nodeLayer) {
        const visible = new Set(Object.keys(nodeLayer));
        return lineageEdges.filter(e => {
            return visible.has(e.from.toLowerCase()) && visible.has(e.to.toLowerCase());
        });
    }

    // SVG rendering
    let currentLineage = null;
    let allNodeEls = [], allEdgeEls = [], allLabelEls = [], allEdgeLabelEls = [];
    let lineagePositions = {};

    function renderLineage(lineageData) {
        // Clear
        while (svg.firstChild) svg.removeChild(svg.firstChild);
        allNodeEls = []; allEdgeEls = []; allLabelEls = []; allEdgeLabelEls = [];

        const { positions, layerKeys } = layoutLineage(lineageData);
        lineagePositions = positions;
        const visibleEdges = getLineageEdges(lineageData.nodeLayer);

        // Compute bounds for viewBox
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        for (const pid in positions) {
            const p = positions[pid];
            minX = Math.min(minX, p.x - 10);
            minY = Math.min(minY, p.y - 30);
            maxX = Math.max(maxX, p.x + NODE_W + 10);
            maxY = Math.max(maxY, p.y + NODE_H + 10);
        }
        const pad = 50;
        vb = { x: minX - pad, y: minY - pad, w: (maxX - minX) + pad * 2, h: (maxY - minY) + pad * 2 };
        svg.setAttribute('width', W);
        svg.setAttribute('height', H);
        updateVB();

        // Defs — arrow marker
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
        marker.setAttribute('id', 'lineage-arrow'); marker.setAttribute('viewBox', '0 0 10 10');
        marker.setAttribute('refX', '10'); marker.setAttribute('refY', '5');
        marker.setAttribute('markerWidth', '6'); marker.setAttribute('markerHeight', '6');
        marker.setAttribute('orient', 'auto');
        const mp = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        mp.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z'); mp.setAttribute('fill', '#4fc3f7');
        marker.appendChild(mp); defs.appendChild(marker); svg.appendChild(defs);

        const edgeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        const nodeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        const labelGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        svg.appendChild(edgeGroup); svg.appendChild(nodeGroup); svg.appendChild(labelGroup);

        // Tooltip
        let tip = container.querySelector('.graph-tooltip');
        if (!tip) {
            tip = document.createElement('div'); tip.className = 'graph-tooltip'; container.appendChild(tip);
        }

        // Controls
        let ctrl = container.querySelector('.graph-controls');
        if (!ctrl) {
            ctrl = document.createElement('div'); ctrl.className = 'graph-controls';
            ctrl.innerHTML = '<button id="lineage-zi" title="Zoom in">+</button><button id="lineage-zo" title="Zoom out">&minus;</button><button id="lineage-zr" title="Fit all">&#8634;</button><button id="lineage-reorder" title="Auto-align">&#9638;</button><button id="lineage-fs" title="Fullscreen">&#x26F6;</button>';
            container.appendChild(ctrl);
        }

        // Draw layer headers
        layerKeys.forEach(layerNum => {
            const nodesInLayer = lineageData.layers[layerNum];
            if (!nodesInLayer || nodesInLayer.length === 0) return;
            const firstPos = positions[nodesInLayer[0].toLowerCase()];
            if (!firstPos) return;
            const headerText = layerNum === 0 ? 'Selected' :
                layerNum < 0 ? `Sources (${layerNum})` :
                `Consumers (+${layerNum})`;
            const hdr = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            hdr.textContent = headerText;
            hdr.setAttribute('x', firstPos.x + NODE_W / 2);
            hdr.setAttribute('y', minY - 5);
            hdr.setAttribute('text-anchor', 'middle');
            hdr.setAttribute('fill', layerNum === 0 ? '#e94560' : '#555');
            hdr.setAttribute('font-size', '12');
            hdr.setAttribute('font-weight', layerNum === 0 ? 'bold' : 'normal');
            labelGroup.appendChild(hdr);
        });

        // Draw edges
        visibleEdges.forEach(e => {
            const fromPos = positions[e.from.toLowerCase()];
            const toPos = positions[e.to.toLowerCase()];
            if (!fromPos || !toPos) return;

            // Determine direction: from should be left of to
            let fx, fy, tx, ty;
            if (fromPos.x < toPos.x) {
                fx = fromPos.x + NODE_W; fy = fromPos.y + NODE_H / 2;
                tx = toPos.x; ty = toPos.y + NODE_H / 2;
            } else if (fromPos.x > toPos.x) {
                fx = fromPos.x; fy = fromPos.y + NODE_H / 2;
                tx = toPos.x + NODE_W; ty = toPos.y + NODE_H / 2;
            } else {
                fx = fromPos.x + NODE_W / 2; fy = fromPos.y + NODE_H;
                tx = toPos.x + NODE_W / 2; ty = toPos.y;
            }

            const cx1 = fx + (tx - fx) * 0.4, cx2 = fx + (tx - fx) * 0.6;
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', `M ${fx} ${fy} C ${cx1} ${fy}, ${cx2} ${ty}, ${tx} ${ty}`);
            path.setAttribute('fill', 'none');
            const isCycleEdge = cycleNodePairs.has(e.from.toLowerCase() + '|' + e.to.toLowerCase());
            const color = isCycleEdge ? '#e94560' : (edgeColors[e.edgeType] || '#4fc3f7');
            path.setAttribute('stroke', color);
            path.setAttribute('stroke-width', '1.8');
            path.setAttribute('stroke-opacity', '0.6');
            if (e.edgeType !== 'fk') path.setAttribute('stroke-dasharray', '6,3');
            path.setAttribute('marker-end', 'url(#lineage-arrow)');
            path.style.cursor = 'pointer';
            edgeGroup.appendChild(path);

            // Edge label at midpoint
            const mx = (fx + tx) / 2, my = (fy + ty) / 2;
            const elbl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            elbl.textContent = e.label;
            elbl.setAttribute('x', mx); elbl.setAttribute('y', my - 6);
            elbl.setAttribute('text-anchor', 'middle');
            elbl.setAttribute('fill', '#555'); elbl.setAttribute('font-size', '9');
            elbl.setAttribute('pointer-events', 'none');
            edgeGroup.appendChild(elbl);

            // Edge hover tooltip
            path.addEventListener('mouseenter', (ev) => {
                tip.innerHTML = `<strong>${e.label}</strong><br>${e.from} &rarr; ${e.to}`;
                tip.style.display = 'block'; const cr = container.getBoundingClientRect();
                tip.style.left = (ev.clientX-cr.left+15)+'px'; tip.style.top = (ev.clientY-cr.top-10)+'px';
                path.setAttribute('stroke-opacity','1'); path.setAttribute('stroke-width','3');
            });
            path.addEventListener('mousemove', (ev) => { const cr = container.getBoundingClientRect(); tip.style.left=(ev.clientX-cr.left+15)+'px'; tip.style.top=(ev.clientY-cr.top-10)+'px'; });
            path.addEventListener('mouseleave', () => { tip.style.display='none'; path.setAttribute('stroke-opacity','0.6'); path.setAttribute('stroke-width','1.8'); });

            allEdgeEls.push({ el: path, labelEl: elbl, from: e.from.toLowerCase(), to: e.to.toLowerCase() });
        });

        // Draw nodes
        for (const layerNum of layerKeys) {
            const nodesInLayer = lineageData.layers[layerNum];
            if (!nodesInLayer) continue;
            nodesInLayer.forEach(nid => {
                const pos = positions[nid.toLowerCase()];
                if (!pos) return;
                const nData = nodeMap[nid.toLowerCase()];
                const nType = nData ? nData.type : 'table';
                const isSelected = nid.toLowerCase() === lineageData.selectedId.toLowerCase();
                const isExternal = nType === 'external';
                const color = typeColors[nType] || '#e94560';

                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('transform', `translate(${pos.x},${pos.y})`);
                g.style.cursor = 'pointer';

                // Background rect
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('width', NODE_W); rect.setAttribute('height', NODE_H);
                rect.setAttribute('rx', '6');
                rect.setAttribute('fill', '#16213e');
                rect.setAttribute('stroke', isSelected ? '#ffffff' : color);
                rect.setAttribute('stroke-width', isSelected ? '2.5' : '1.5');
                if (isExternal) rect.setAttribute('stroke-dasharray', '4,2');
                g.appendChild(rect);

                // Glow for selected
                if (isSelected) {
                    rect.setAttribute('filter', 'url(#lineage-glow)');
                    // Add glow filter if not present
                    if (!svg.querySelector('#lineage-glow')) {
                        const filter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
                        filter.setAttribute('id', 'lineage-glow');
                        const blur = document.createElementNS('http://www.w3.org/2000/svg', 'feGaussianBlur');
                        blur.setAttribute('stdDeviation', '3'); blur.setAttribute('result', 'blur');
                        const merge = document.createElementNS('http://www.w3.org/2000/svg', 'feMerge');
                        const m1 = document.createElementNS('http://www.w3.org/2000/svg', 'feMergeNode'); m1.setAttribute('in', 'blur');
                        const m2 = document.createElementNS('http://www.w3.org/2000/svg', 'feMergeNode'); m2.setAttribute('in', 'SourceGraphic');
                        merge.appendChild(m1); merge.appendChild(m2);
                        filter.appendChild(blur); filter.appendChild(merge);
                        defs.appendChild(filter);
                    }
                }

                // Type indicator (small colored bar at left)
                const bar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                bar.setAttribute('width', '4'); bar.setAttribute('height', NODE_H);
                bar.setAttribute('rx', '2'); bar.setAttribute('fill', color);
                g.appendChild(bar);

                // Name label
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                const displayName = nid.length > 22 ? nid.substring(0, 20) + '...' : nid;
                label.textContent = displayName;
                label.setAttribute('x', 12); label.setAttribute('y', NODE_H / 2 - 2);
                label.setAttribute('fill', '#e0e0e0'); label.setAttribute('font-size', '11');
                label.setAttribute('dominant-baseline', 'middle');
                label.setAttribute('pointer-events', 'none');
                g.appendChild(label);

                // Type badge
                const badge = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                badge.textContent = nType.toUpperCase();
                badge.setAttribute('x', NODE_W - 6); badge.setAttribute('y', NODE_H / 2 - 2);
                badge.setAttribute('text-anchor', 'end');
                badge.setAttribute('fill', color); badge.setAttribute('font-size', '8');
                badge.setAttribute('dominant-baseline', 'middle');
                badge.setAttribute('opacity', '0.7');
                badge.setAttribute('pointer-events', 'none');
                g.appendChild(badge);

                // Cycle warning badge
                if (cycleNodeIds.has(nid.toLowerCase())) {
                    const cyBadge = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    cyBadge.textContent = '\u27F3 Cycle';
                    cyBadge.setAttribute('x', NODE_W - 6); cyBadge.setAttribute('y', NODE_H - 4);
                    cyBadge.setAttribute('text-anchor', 'end');
                    cyBadge.setAttribute('fill', '#e94560'); cyBadge.setAttribute('font-size', '7');
                    cyBadge.setAttribute('pointer-events', 'none');
                    g.appendChild(cyBadge);
                    rect.setAttribute('stroke', '#e94560');
                    rect.setAttribute('stroke-dasharray', '3,2');
                }

                nodeGroup.appendChild(g);

                // Hover: highlight full path through this node
                const nodeId = nid.toLowerCase();
                g.addEventListener('mouseenter', (ev) => {
                    const cycleNote = cycleNodeIds.has(nodeId) ? '<br><span style="color:#e94560">\u27F3 Part of circular dependency</span>' : '';
                    tip.innerHTML = `<strong>${nid}</strong><br>Type: ${nType}<br>Layer: ${pos.layer === 0 ? 'Selected' : pos.layer < 0 ? 'Source (' + pos.layer + ')' : 'Consumer (+' + pos.layer + ')'}` + cycleNote;
                    tip.style.display = 'block'; const cr = container.getBoundingClientRect();
                    tip.style.left = (ev.clientX-cr.left+15)+'px'; tip.style.top = (ev.clientY-cr.top-10)+'px';

                    // BFS both directions from hovered node within visible lineage
                    const pathNodes = new Set([nodeId]);
                    const pathEdges = new Set();

                    // Upstream from hovered
                    let q = [nodeId];
                    while (q.length > 0) {
                        const nq = [];
                        for (const cid of q) {
                            allEdgeEls.forEach((ee, ei) => {
                                if (ee.to === cid && !pathNodes.has(ee.from)) {
                                    pathNodes.add(ee.from);
                                    pathEdges.add(ei);
                                    nq.push(ee.from);
                                }
                            });
                        }
                        q = nq;
                    }

                    // Downstream from hovered
                    q = [nodeId];
                    while (q.length > 0) {
                        const nq = [];
                        for (const cid of q) {
                            allEdgeEls.forEach((ee, ei) => {
                                if (ee.from === cid && !pathNodes.has(ee.to)) {
                                    pathNodes.add(ee.to);
                                    pathEdges.add(ei);
                                    nq.push(ee.to);
                                }
                            });
                        }
                        q = nq;
                    }

                    // Dim non-path
                    allNodeEls.forEach(ne => {
                        const inPath = pathNodes.has(ne.id);
                        ne.el.setAttribute('opacity', inPath ? '1' : '0.15');
                    });
                    allEdgeEls.forEach((ee, ei) => {
                        const inPath = pathEdges.has(ei);
                        ee.el.setAttribute('stroke-opacity', inPath ? '0.9' : '0.05');
                        ee.labelEl.setAttribute('opacity', inPath ? '1' : '0.05');
                    });
                });

                g.addEventListener('mousemove', (ev) => { const cr = container.getBoundingClientRect(); tip.style.left=(ev.clientX-cr.left+15)+'px'; tip.style.top=(ev.clientY-cr.top-10)+'px'; });

                g.addEventListener('mouseleave', () => {
                    tip.style.display = 'none';
                    allNodeEls.forEach(ne => ne.el.setAttribute('opacity', '1'));
                    allEdgeEls.forEach(ee => { ee.el.setAttribute('stroke-opacity', '0.6'); ee.labelEl.setAttribute('opacity', '1'); });
                });

                // Click to re-center lineage on this node
                g.addEventListener('click', () => {
                    searchInput.value = nid;
                    showLineage();
                });

                allNodeEls.push({ el: g, id: nodeId });
            });
        }

        // No connections case
        const allLayerNodes = Object.values(lineageData.layers).flat();
        if (allLayerNodes.length === 1) {
            const noConn = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            const p0 = positions[allLayerNodes[0].toLowerCase()];
            noConn.textContent = 'No lineage connections found for this object';
            noConn.setAttribute('x', p0.x + NODE_W / 2); noConn.setAttribute('y', p0.y + NODE_H + 30);
            noConn.setAttribute('text-anchor', 'middle');
            noConn.setAttribute('fill', '#555'); noConn.setAttribute('font-size', '12');
            labelGroup.appendChild(noConn);
        }

        currentLineage = lineageData;
    }

    // Show lineage action
    function showLineage() {
        const val = searchInput.value.trim();
        if (!val) return;
        const lineageData = computeLineage(val);
        if (!lineageData) { alert('Object not found: ' + val); return; }
        emptyMsg.style.display = 'none';
        svg.style.display = 'block';
        renderLineage(lineageData);
    }

    document.getElementById('lineage-show').addEventListener('click', showLineage);
    searchInput.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') showLineage(); });

    // Clear
    document.getElementById('lineage-clear').addEventListener('click', () => {
        while (svg.firstChild) svg.removeChild(svg.firstChild);
        svg.style.display = 'none';
        emptyMsg.style.display = 'block';
        searchInput.value = '';
        currentLineage = null;
        allNodeEls = []; allEdgeEls = []; allLabelEls = []; allEdgeLabelEls = [];
    });

    // Zoom/pan
    function zoomBy(f,cx,cy) { const nw=vb.w/f,nh=vb.h/f; vb.x=cx-(cx-vb.x)/f; vb.y=cy-(cy-vb.y)/f; vb.w=nw;vb.h=nh; updateVB(); }
    svg.addEventListener('wheel', (ev) => { ev.preventDefault(); const p=s2w(ev.clientX,ev.clientY); zoomBy(ev.deltaY<0?1.15:1/1.15,p.x,p.y); }, {passive:false});

    function fitAll() {
        if (!currentLineage) return;
        let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
        for (const pid in lineagePositions) {
            const p = lineagePositions[pid];
            minX=Math.min(minX,p.x); minY=Math.min(minY,p.y-30);
            maxX=Math.max(maxX,p.x+NODE_W); maxY=Math.max(maxY,p.y+NODE_H);
        }
        if (minX===Infinity) return;
        const pad=50;
        vb={x:minX-pad, y:minY-pad, w:maxX-minX+pad*2, h:maxY-minY+pad*2};
        updateVB();
    }

    // Update edge paths based on current node positions
    function updateEdges() {
        allEdgeEls.forEach(ee => {
            const fromPos = lineagePositions[ee.from];
            const toPos = lineagePositions[ee.to];
            if (!fromPos || !toPos) return;
            let fx, fy, tx, ty;
            if (fromPos.x < toPos.x) {
                fx = fromPos.x + NODE_W; fy = fromPos.y + NODE_H / 2;
                tx = toPos.x; ty = toPos.y + NODE_H / 2;
            } else if (fromPos.x > toPos.x) {
                fx = fromPos.x; fy = fromPos.y + NODE_H / 2;
                tx = toPos.x + NODE_W; ty = toPos.y + NODE_H / 2;
            } else {
                fx = fromPos.x + NODE_W / 2; fy = fromPos.y + NODE_H;
                tx = toPos.x + NODE_W / 2; ty = toPos.y;
            }
            const cx1 = fx + (tx - fx) * 0.4, cx2 = fx + (tx - fx) * 0.6;
            ee.el.setAttribute('d', `M ${fx} ${fy} C ${cx1} ${fy}, ${cx2} ${ty}, ${tx} ${ty}`);
            const mx = (fx + tx) / 2, my = (fy + ty) / 2;
            ee.labelEl.setAttribute('x', mx); ee.labelEl.setAttribute('y', my - 6);
        });
    }

    // Auto-align: barycenter crossing minimization within layers
    function autoAlign() {
        if (!currentLineage) return;
        const { layers, nodeLayer } = currentLineage;
        const layerKeys = Object.keys(layers).map(Number).sort((a, b) => a - b);

        // Build adjacency from visible edges
        const adj = {}; // nodeId -> Set of connected nodeIds
        allEdgeEls.forEach(ee => {
            if (!adj[ee.from]) adj[ee.from] = new Set();
            if (!adj[ee.to]) adj[ee.to] = new Set();
            adj[ee.from].add(ee.to);
            adj[ee.to].add(ee.from);
        });

        // Several passes of barycenter ordering
        for (let pass = 0; pass < 8; pass++) {
            // Forward sweep (left to right)
            for (let li = 1; li < layerKeys.length; li++) {
                const layerNum = layerKeys[li];
                const nodesInLayer = layers[layerNum];
                if (!nodesInLayer || nodesInLayer.length <= 1) continue;
                // Compute barycenter for each node based on neighbors in previous layer
                const prevLayer = layerKeys[li - 1];
                const prevNodes = layers[prevLayer] || [];
                const prevPositions = {};
                prevNodes.forEach((nid, idx) => { prevPositions[nid.toLowerCase()] = idx; });

                const barycenters = nodesInLayer.map(nid => {
                    const nid_l = nid.toLowerCase();
                    const neighbors = adj[nid_l] || new Set();
                    let sum = 0, count = 0;
                    for (const nb of neighbors) {
                        if (prevPositions[nb] !== undefined) { sum += prevPositions[nb]; count++; }
                    }
                    return { nid, bc: count > 0 ? sum / count : Infinity };
                });
                barycenters.sort((a, b) => a.bc - b.bc);
                layers[layerNum] = barycenters.map(b => b.nid);
            }
            // Backward sweep (right to left)
            for (let li = layerKeys.length - 2; li >= 0; li--) {
                const layerNum = layerKeys[li];
                const nodesInLayer = layers[layerNum];
                if (!nodesInLayer || nodesInLayer.length <= 1) continue;
                const nextLayer = layerKeys[li + 1];
                const nextNodes = layers[nextLayer] || [];
                const nextPositions = {};
                nextNodes.forEach((nid, idx) => { nextPositions[nid.toLowerCase()] = idx; });

                const barycenters = nodesInLayer.map(nid => {
                    const nid_l = nid.toLowerCase();
                    const neighbors = adj[nid_l] || new Set();
                    let sum = 0, count = 0;
                    for (const nb of neighbors) {
                        if (nextPositions[nb] !== undefined) { sum += nextPositions[nb]; count++; }
                    }
                    return { nid, bc: count > 0 ? sum / count : Infinity };
                });
                barycenters.sort((a, b) => a.bc - b.bc);
                layers[layerNum] = barycenters.map(b => b.nid);
            }
        }

        // Reassign y positions based on new ordering
        const totalLayers = layerKeys.length;
        const totalW = totalLayers * LAYER_W;
        const offsetX = Math.max(40, (W - totalW) / 2);

        layerKeys.forEach((layerNum, li) => {
            const nodesInLayer = layers[layerNum];
            const totalH = nodesInLayer.length * (NODE_H + GAP) - GAP;
            const offsetY = Math.max(60, (H - totalH) / 2);
            nodesInLayer.forEach((nid, ni) => {
                const pos = lineagePositions[nid.toLowerCase()];
                if (!pos) return;
                pos.x = offsetX + li * LAYER_W;
                pos.y = offsetY + ni * (NODE_H + GAP);
            });
        });

        // Update SVG node positions & edges
        allNodeEls.forEach(ne => {
            const pos = lineagePositions[ne.id];
            if (pos) ne.el.setAttribute('transform', `translate(${pos.x},${pos.y})`);
        });
        updateEdges();
        fitAll();
    }

    // Attach control events (deferred until controls exist)
    function attachControls() {
        const zi = document.getElementById('lineage-zi');
        const zo = document.getElementById('lineage-zo');
        const zr = document.getElementById('lineage-zr');
        const reorder = document.getElementById('lineage-reorder');
        const fs = document.getElementById('lineage-fs');
        if (!zi) return;
        zi.addEventListener('click', () => { zoomBy(1.3,vb.x+vb.w/2,vb.y+vb.h/2); });
        zo.addEventListener('click', () => { zoomBy(1/1.3,vb.x+vb.w/2,vb.y+vb.h/2); });
        zr.addEventListener('click', () => { fitAll(); });
        reorder.addEventListener('click', () => { autoAlign(); });
        fs.addEventListener('click', () => {
            if (document.fullscreenElement) document.exitFullscreen();
            else container.requestFullscreen().catch(() => {});
        });
        document.addEventListener('fullscreenchange', () => {
            if (document.fullscreenElement === container) {
                container.style.height = '100vh'; container.style.borderRadius = '0';
                svg.setAttribute('width', screen.width); svg.setAttribute('height', screen.height);
                if (fs) { fs.textContent = '\u2716'; fs.title = 'Exit fullscreen'; }
            } else if (!document.fullscreenElement || document.fullscreenElement.id !== 'lineage-container') {
                container.style.height = ''; container.style.borderRadius = '';
                svg.setAttribute('width', W); svg.setAttribute('height', H);
                if (fs) { fs.textContent = '\u26F6'; fs.title = 'Fullscreen'; }
            }
            fitAll();
        });
    }

    // Drag nodes + Pan on SVG
    let dragNodeEl = null, dragOff = {x:0,y:0};
    let isPanning = false, panStart = {x:0,y:0}, vbStart = {x:0,y:0};

    svg.addEventListener('mousedown', (ev) => {
        const p = s2w(ev.clientX, ev.clientY);
        // Check if clicking a node
        for (const ne of allNodeEls) {
            const pos = lineagePositions[ne.id];
            if (!pos) continue;
            if (p.x >= pos.x && p.x <= pos.x + NODE_W && p.y >= pos.y && p.y <= pos.y + NODE_H) {
                dragNodeEl = ne;
                dragOff = { x: p.x - pos.x, y: p.y - pos.y };
                svg.style.cursor = 'grabbing';
                return;
            }
        }
        // Otherwise pan
        isPanning = true; panStart = {x:ev.clientX,y:ev.clientY}; vbStart = {x:vb.x,y:vb.y};
        svg.style.cursor = 'move';
    });
    svg.addEventListener('mousemove', (ev) => {
        if (dragNodeEl) {
            const p = s2w(ev.clientX, ev.clientY);
            const pos = lineagePositions[dragNodeEl.id];
            if (pos) {
                pos.x = p.x - dragOff.x;
                pos.y = p.y - dragOff.y;
                dragNodeEl.el.setAttribute('transform', `translate(${pos.x},${pos.y})`);
                updateEdges();
            }
        } else if (isPanning) {
            const r = svg.getBoundingClientRect();
            vb.x = vbStart.x - (ev.clientX-panStart.x)/r.width*vb.w;
            vb.y = vbStart.y - (ev.clientY-panStart.y)/r.height*vb.h;
            updateVB();
        }
    });
    svg.addEventListener('mouseup', () => { dragNodeEl=null; isPanning=false; svg.style.cursor='default'; });
    svg.addEventListener('mouseleave', () => { dragNodeEl=null; isPanning=false; svg.style.cursor='default'; });

    // Render controls once on first show (they are created inside renderLineage)
    const origShow = showLineage;
    let controlsAttached = false;
    // We attach controls after first render
    const observer = new MutationObserver(() => {
        if (!controlsAttached && document.getElementById('lineage-zi')) {
            attachControls();
            controlsAttached = true;
            observer.disconnect();
        }
    });
    observer.observe(container, { childList: true, subtree: true });
})();
""";
    }

    private static string GetCss() => """
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #1a1a2e; color: #e0e0e0; line-height: 1.6; }
        header { background: #16213e; padding: 2rem; border-bottom: 3px solid #0f3460; }
        h1 { color: #e94560; }
        h2 { color: #0f3460; background: #16213e; padding: 0.8rem 1rem; margin: 1.5rem 0 1rem; border-left: 4px solid #e94560; }
        h3 { color: #e94560; margin: 1rem 0 0.5rem; }
        h4 { color: #4fc3f7; margin: 0.5rem 0 0.3rem; }
        nav { background: #16213e; padding: 0.5rem 1rem; display: flex; gap: 1rem; border-bottom: 1px solid #0f3460; position: sticky; top: 0; z-index: 100; }
        nav a { color: #e94560; text-decoration: none; padding: 0.3rem 0.8rem; border-radius: 4px; }
        nav a:hover { background: #0f3460; }
        main { max-width: 1400px; margin: 0 auto; padding: 1rem 2rem; }
        table { width: 100%; border-collapse: collapse; margin: 0.5rem 0 1rem; background: #16213e; border-radius: 4px; overflow: hidden; }
        th { background: #0f3460; color: #e0e0e0; text-align: left; padding: 0.6rem 0.8rem; font-weight: 600; }
        td { padding: 0.4rem 0.8rem; border-bottom: 1px solid #1a1a2e; }
        tr:hover td { background: #1a1a3e; }
        .meta { color: #888; font-size: 0.9em; }
        .ok { color: #4ecca3; }
        .warn { color: #f0a500; }
        .error { color: #e94560; }
        .info { color: #4fc3f7; }
        .summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem; margin: 1rem 0; }
        .card { background: #16213e; padding: 1.2rem; border-radius: 8px; text-align: center; border: 1px solid #0f3460; }
        .card h3 { color: #4ecca3; font-size: 2em; margin: 0; }
        .card p { color: #888; margin: 0.3rem 0 0; }
        details { margin: 0.5rem 0; }
        summary { cursor: pointer; color: #4fc3f7; padding: 0.3rem 0; }
        footer { text-align: center; padding: 2rem; color: #555; border-top: 1px solid #0f3460; margin-top: 2rem; }
        #graph-container, #erd-container, #lineage-container { position: relative; background: #0d0d1a; border: 1px solid #0f3460; border-radius: 8px; margin: 1rem 0; overflow: hidden; }
        #graph-container:fullscreen, #erd-container:fullscreen, #lineage-container:fullscreen { background: #0d0d1a; padding: 0; }
        #graph-container:fullscreen #dep-graph, #erd-container:fullscreen #erd-svg, #lineage-container:fullscreen #lineage-svg { width: 100vw; height: 100vh; }
        #dep-graph, #erd-svg, #lineage-svg { display: block; }
        .lineage-controls { display: flex; align-items: center; gap: 0.6rem; flex-wrap: wrap; margin: 0.5rem 0; padding: 0.5rem 0.8rem; background: #16213e; border-radius: 6px; border: 1px solid #0f3460; }
        .lineage-controls input[type="text"] { background: #0d0d1a; border: 1px solid #0f3460; color: #e0e0e0; padding: 0.4rem 0.6rem; border-radius: 4px; font-size: 0.9em; width: 260px; }
        .lineage-controls input[type="text"]::placeholder { color: #555; }
        .lineage-controls button { background: #0f3460; border: 1px solid #4fc3f7; color: #e0e0e0; padding: 0.4rem 0.8rem; border-radius: 4px; cursor: pointer; font-size: 0.85em; }
        .lineage-controls button:hover { background: #1a5c8e; }
        .lineage-empty { text-align: center; padding: 3rem; color: #555; font-size: 1.1em; }
        .graph-tooltip { display: none; position: absolute; background: #16213e; border: 1px solid #0f3460; padding: 0.6rem 0.8rem; border-radius: 6px; font-size: 0.85em; pointer-events: none; z-index: 10; color: #e0e0e0; box-shadow: 0 4px 12px rgba(0,0,0,0.5); }
        .graph-controls { position: absolute; top: 10px; right: 10px; display: flex; flex-direction: column; gap: 4px; z-index: 10; }
        .graph-controls button { width: 32px; height: 32px; border: 1px solid #0f3460; background: #16213e; color: #e0e0e0; font-size: 18px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .graph-controls button:hover { background: #0f3460; }
        .graph-filters { display: flex; align-items: center; gap: 0.8rem; flex-wrap: wrap; margin: 0.5rem 0; padding: 0.5rem 0.8rem; background: #16213e; border-radius: 6px; border: 1px solid #0f3460; }
        .filter-toggle { display: inline-flex; align-items: center; gap: 0.3rem; cursor: pointer; padding: 0.25rem 0.6rem; border-radius: 4px; border: 1px solid var(--clr); color: var(--clr); font-size: 0.85em; user-select: none; transition: all 0.15s; }
        .filter-toggle:has(input:checked) { background: color-mix(in srgb, var(--clr) 20%, transparent); }
        .filter-toggle:has(input:not(:checked)) { opacity: 0.4; border-style: dashed; }
        .filter-toggle input { display: none; }
        @keyframes cycle-pulse { 0%,100% { stroke: #e94560; stroke-opacity: 0.6; } 50% { stroke: #ff2255; stroke-opacity: 1; } }
        .cycle-node { animation: cycle-pulse 2s ease-in-out infinite; }
        .cycle-warning { background: rgba(233,69,96,0.12); border: 1px solid #e94560; border-radius: 6px; padding: 0.8rem 1.2rem; margin: 0.8rem 0; color: #e94560; }
        .cycle-warning details { margin-top: 0.4rem; }
        .cycle-warning summary { color: #e94560; cursor: pointer; }
        .cycle-warning ol { color: #e0e0e0; margin: 0.4rem 0 0; padding-left: 1.5rem; }
        .cycle-warning li { margin: 0.2rem 0; }
        .cycle-chain { color: #e94560; text-decoration: none; cursor: pointer; font-family: monospace; font-size: 0.9em; }
        .cycle-chain:hover { text-decoration: underline; color: #ff6b8a; }
        .impact-detail { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; padding: 0.8rem; background: #0d0d1a; border-radius: 6px; margin: 0.5rem 0; }
        .impact-detail ul { list-style: none; padding-left: 0.5rem; }
        .impact-detail li { padding: 0.15rem 0; }
        .impact-detail li::before { content: "→ "; color: #4fc3f7; }
        """;
}
