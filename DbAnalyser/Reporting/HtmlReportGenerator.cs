using System.Text;
using System.Text.Json;
using System.Web;
using DbAnalyser.Analyzers;
using DbAnalyser.Models.Quality;
using DbAnalyser.Models.Relationships;
using DbAnalyser.Models.Schema;

namespace DbAnalyser.Reporting;

public class HtmlReportGenerator : IReportGenerator
{
    public OutputFormat Format => OutputFormat.Html;

    public async Task GenerateAsync(AnalysisResult result, string? outputPath, CancellationToken ct = default)
    {
        var path = outputPath ?? $"DbAnalysis_{result.DatabaseName}_{result.AnalyzedAt:yyyyMMdd_HHmmss}.html";
        var html = BuildHtml(result);
        await File.WriteAllTextAsync(path, html, ct);
        Console.WriteLine($"HTML report written to: {path}");
    }

    private string BuildHtml(AnalysisResult result)
    {
        var sb = new StringBuilder();
        sb.AppendLine("<!DOCTYPE html>");
        sb.AppendLine("<html lang=\"en\">");
        sb.AppendLine("<head>");
        sb.AppendLine("<meta charset=\"UTF-8\">");
        sb.AppendLine("<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">");
        sb.AppendLine($"<title>Database Analysis - {E(result.DatabaseName)}</title>");
        sb.AppendLine("<style>");
        sb.AppendLine(GetCss());
        sb.AppendLine("</style>");
        sb.AppendLine("</head>");
        sb.AppendLine("<body>");
        sb.AppendLine($"<header><h1>Database Analysis: {E(result.DatabaseName)}</h1>");
        sb.AppendLine($"<p class=\"meta\">Analyzed at {result.AnalyzedAt:yyyy-MM-dd HH:mm:ss} UTC</p></header>");

        sb.AppendLine("<nav>");
        if (result.Relationships?.Dependencies.Count > 0) sb.AppendLine("<a href=\"#dependencies\">Dependencies</a>");
        if (result.Schema?.Tables.Count > 0) sb.AppendLine("<a href=\"#erd\">ERD</a>");
        if (result.Schema is not null) sb.AppendLine("<a href=\"#schema\">Schema</a>");
        if (result.Profiles is not null) sb.AppendLine("<a href=\"#profiling\">Profiling</a>");
        if (result.Relationships is not null) sb.AppendLine("<a href=\"#relationships\">Relationships</a>");
        if (result.QualityIssues is not null) sb.AppendLine("<a href=\"#quality\">Quality</a>");
        sb.AppendLine("</nav>");

        sb.AppendLine("<main>");

        if (result.Relationships?.Dependencies.Count > 0)
            BuildDependencySection(sb, result);

        if (result.Schema?.Tables.Count > 0)
            BuildErdSection(sb, result);

        if (result.Schema is not null)
            BuildSchemaSection(sb, result);

        if (result.Profiles is not null)
            BuildProfilingSection(sb, result);

        if (result.Relationships is not null)
            BuildRelationshipsSection(sb, result);

        if (result.QualityIssues is not null)
            BuildQualitySection(sb, result);

        sb.AppendLine("</main>");
        sb.AppendLine("<footer><p>Generated by DbAnalyser</p></footer>");

        if (result.Relationships?.Dependencies.Count > 0)
        {
            sb.AppendLine("<script>");
            sb.AppendLine(GetGraphJs(result));
            sb.AppendLine("</script>");
        }

        if (result.Schema?.Tables.Count > 0)
        {
            sb.AppendLine("<script>");
            sb.AppendLine(GetErdJs(result));
            sb.AppendLine("</script>");
        }

        sb.AppendLine("</body></html>");

        return sb.ToString();
    }

    private void BuildDependencySection(StringBuilder sb, AnalysisResult result)
    {
        var deps = result.Relationships!.Dependencies;
        var connected = deps.Where(d => d.DirectConnections > 0).ToList();
        var orphaned = deps.Where(d => d.DirectConnections == 0).ToList();

        sb.AppendLine("<section id=\"dependencies\">");
        sb.AppendLine("<h2>Dependency Overview</h2>");

        var tableCount = deps.Count(d => d.ObjectType == "Table");
        var viewCount = deps.Count(d => d.ObjectType == "View");
        var sprocCount = deps.Count(d => d.ObjectType == "Procedure");
        var funcCount = deps.Count(d => d.ObjectType == "Function");
        var triggerCount = deps.Count(d => d.ObjectType == "Trigger");
        var synonymCount = deps.Count(d => d.ObjectType == "Synonym");
        var externalCount = deps.Count(d => d.ObjectType == "External");
        var jobCount = deps.Count(d => d.ObjectType == "Job");
        var crossDbDeps = result.Relationships!.ViewDependencies.Where(d => d.IsCrossDatabase).ToList();

        // Summary cards
        sb.AppendLine("<div class=\"summary-grid\">");
        sb.AppendLine($"<div class=\"card\"><h3>{tableCount}</h3><p>Tables</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{viewCount}</h3><p>Views</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{sprocCount}</h3><p>Procedures</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{funcCount}</h3><p>Functions</p></div>");
        if (triggerCount > 0)
            sb.AppendLine($"<div class=\"card\"><h3>{triggerCount}</h3><p>Triggers</p></div>");
        if (synonymCount > 0)
            sb.AppendLine($"<div class=\"card\"><h3>{synonymCount}</h3><p>Synonyms</p></div>");
        if (jobCount > 0)
            sb.AppendLine($"<div class=\"card\"><h3>{jobCount}</h3><p>Jobs</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{connected.Count}</h3><p>Connected</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{orphaned.Count}</h3><p>Standalone</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{result.Relationships!.ExplicitRelationships.Count}</h3><p>Foreign Keys</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{result.Relationships!.ViewDependencies.Count}</h3><p>Object Dependencies</p></div>");
        if (externalCount > 0)
            sb.AppendLine($"<div class=\"card\"><h3>{externalCount}</h3><p>Cross-DB References</p></div>");
        sb.AppendLine("</div>");

        // Interactive graph
        sb.AppendLine("<h3>Relationship Graph</h3>");
        sb.AppendLine("<p class=\"meta\">Scroll to zoom. Drag empty space to pan. Drag nodes to rearrange. Hover for details. Node size = importance.</p>");

        // Node type filters
        sb.AppendLine("<div class=\"graph-filters\">");
        sb.AppendLine("<span class=\"meta\">Objects:</span>");
        sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#e94560\"><input type=\"checkbox\" value=\"table\" checked onchange=\"toggleNodeFilter(this)\"><span>&#9679; Tables ({tableCount})</span></label>");
        sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#4ecca3\"><input type=\"checkbox\" value=\"view\" checked onchange=\"toggleNodeFilter(this)\"><span>&#9670; Views ({viewCount})</span></label>");
        if (sprocCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#f0a500\"><input type=\"checkbox\" value=\"procedure\" checked onchange=\"toggleNodeFilter(this)\"><span>&#9632; Procedures ({sprocCount})</span></label>");
        if (funcCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#bb86fc\"><input type=\"checkbox\" value=\"function\" checked onchange=\"toggleNodeFilter(this)\"><span>&#9650; Functions ({funcCount})</span></label>");
        if (triggerCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#ff7043\"><input type=\"checkbox\" value=\"trigger\" checked onchange=\"toggleNodeFilter(this)\"><span>&#9889; Triggers ({triggerCount})</span></label>");
        if (synonymCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#78909c\"><input type=\"checkbox\" value=\"synonym\" checked onchange=\"toggleNodeFilter(this)\"><span>&#8801; Synonyms ({synonymCount})</span></label>");
        if (jobCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#26a69a\"><input type=\"checkbox\" value=\"job\" checked onchange=\"toggleNodeFilter(this)\"><span>&#9881; Jobs ({jobCount})</span></label>");
        if (externalCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#ff6b6b\"><input type=\"checkbox\" value=\"external\" checked onchange=\"toggleNodeFilter(this)\"><span>&#9674; External ({externalCount})</span></label>");
        sb.AppendLine("</div>");

        // Edge type filters
        var fkEdgeCount = result.Relationships!.ExplicitRelationships.Count;
        var viewEdgeCount = result.Relationships!.ViewDependencies.Count(d => !d.IsCrossDatabase && d.FromType == "View");
        var sprocEdgeCount = result.Relationships!.ViewDependencies.Count(d => !d.IsCrossDatabase && d.FromType == "Procedure");
        var funcEdgeCount = result.Relationships!.ViewDependencies.Count(d => !d.IsCrossDatabase && d.FromType == "Function");
        var triggerEdgeCount = result.Relationships!.ViewDependencies.Count(d => !d.IsCrossDatabase && d.FromType == "Trigger");
        var synonymEdgeCount = result.Relationships!.ViewDependencies.Count(d => !d.IsCrossDatabase && d.FromType == "Synonym");
        var jobEdgeCount = result.Relationships!.ViewDependencies.Count(d => !d.IsCrossDatabase && d.FromType == "Job");
        var extEdgeCount = result.Relationships!.ViewDependencies.Count(d => d.IsCrossDatabase);

        sb.AppendLine("<div class=\"graph-filters\">");
        sb.AppendLine("<span class=\"meta\">Relations:</span>");
        sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#4fc3f7\"><input type=\"checkbox\" value=\"fk\" checked onchange=\"toggleEdgeFilter(this)\"><span>FK: Table &harr; Table ({fkEdgeCount})</span></label>");
        if (viewEdgeCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#4ecca3\"><input type=\"checkbox\" value=\"view\" checked onchange=\"toggleEdgeFilter(this)\"><span>View &rarr; Table/View ({viewEdgeCount})</span></label>");
        if (sprocEdgeCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#f0a500\"><input type=\"checkbox\" value=\"procedure\" checked onchange=\"toggleEdgeFilter(this)\"><span>Procedure &rarr; Table/View/Func ({sprocEdgeCount})</span></label>");
        if (funcEdgeCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#bb86fc\"><input type=\"checkbox\" value=\"function\" checked onchange=\"toggleEdgeFilter(this)\"><span>Function &rarr; Table/View ({funcEdgeCount})</span></label>");
        if (triggerEdgeCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#ff7043\"><input type=\"checkbox\" value=\"trigger\" checked onchange=\"toggleEdgeFilter(this)\"><span>Trigger &rarr; Table/Proc ({triggerEdgeCount})</span></label>");
        if (synonymEdgeCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#78909c\"><input type=\"checkbox\" value=\"synonym\" checked onchange=\"toggleEdgeFilter(this)\"><span>Synonym &rarr; Table/View ({synonymEdgeCount})</span></label>");
        if (jobEdgeCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#26a69a\"><input type=\"checkbox\" value=\"job\" checked onchange=\"toggleEdgeFilter(this)\"><span>Job &rarr; Table/Proc ({jobEdgeCount})</span></label>");
        if (extEdgeCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#ff6b6b\"><input type=\"checkbox\" value=\"external\" checked onchange=\"toggleEdgeFilter(this)\"><span>Cross-DB ({extEdgeCount})</span></label>");
        sb.AppendLine("</div>");

        sb.AppendLine("<div id=\"graph-container\"><svg id=\"dep-graph\"></svg></div>");

        // Dependency ranking table
        if (connected.Count > 0)
        {
            sb.AppendLine("<h3>Importance Ranking</h3>");
            sb.AppendLine("<p class=\"meta\">Objects ranked by how central they are. \"Referenced By\" = other objects depend on this one. \"Impact\" = total objects transitively affected.</p>");
            sb.AppendLine("<table><thead><tr><th>Rank</th><th>Object</th><th>Type</th><th>Referenced By</th><th>Depends On</th><th>Transitive Impact</th><th>Score</th></tr></thead><tbody>");

            var rank = 1;
            foreach (var dep in connected.OrderByDescending(d => d.ImportanceScore))
            {
                var impactClass = dep.TransitiveImpact.Count > 10 ? "error" : dep.TransitiveImpact.Count > 5 ? "warn" : "";
                var typeClass = dep.ObjectType switch { "View" => "ok", "Procedure" => "warn", "Function" => "info", "Trigger" => "warn", "Synonym" => "info", "Job" => "ok", "External" => "error", _ => "" };
                sb.AppendLine($"<tr><td>{rank++}</td><td><strong>{E(dep.FullName)}</strong></td><td class=\"{typeClass}\">{dep.ObjectType}</td>");
                sb.AppendLine($"<td>{dep.ReferencedBy.Count}</td>");
                sb.AppendLine($"<td>{dep.DependsOn.Count}</td>");
                sb.AppendLine($"<td class=\"{impactClass}\">{dep.TransitiveImpact.Count}</td>");
                sb.AppendLine($"<td>{dep.ImportanceScore}</td></tr>");
            }
            sb.AppendLine("</tbody></table>");

            // Impact details (expandable per core table)
            var coreTables = connected
                .Where(d => d.ReferencedBy.Count > 0)
                .OrderByDescending(d => d.TransitiveImpact.Count)
                .ToList();

            if (coreTables.Count > 0)
            {
                sb.AppendLine("<h3>Impact Analysis</h3>");
                sb.AppendLine("<p class=\"meta\">If you modify a core table, these tables are affected (directly or transitively).</p>");

                foreach (var dep in coreTables)
                {
                    sb.AppendLine($"<details><summary><strong>{E(dep.FullName)}</strong> — {dep.ReferencedBy.Count} direct, {dep.TransitiveImpact.Count} total impact</summary>");
                    sb.AppendLine("<div class=\"impact-detail\">");

                    sb.AppendLine("<div class=\"impact-col\"><h4>Direct dependents</h4><ul>");
                    foreach (var t in dep.ReferencedBy.Order())
                        sb.AppendLine($"<li>{E(t)}</li>");
                    sb.AppendLine("</ul></div>");

                    if (dep.TransitiveImpact.Count > dep.ReferencedBy.Count)
                    {
                        var indirect = dep.TransitiveImpact.Except(dep.ReferencedBy, StringComparer.OrdinalIgnoreCase).Order();
                        sb.AppendLine("<div class=\"impact-col\"><h4>Indirect (transitive)</h4><ul>");
                        foreach (var t in indirect)
                            sb.AppendLine($"<li class=\"meta\">{E(t)}</li>");
                        sb.AppendLine("</ul></div>");
                    }

                    sb.AppendLine("<div class=\"impact-col\"><h4>This table depends on</h4><ul>");
                    foreach (var t in dep.DependsOn.Order())
                        sb.AppendLine($"<li>{E(t)}</li>");
                    if (dep.DependsOn.Count == 0)
                        sb.AppendLine("<li class=\"meta\">None (root table)</li>");
                    sb.AppendLine("</ul></div>");

                    sb.AppendLine("</div></details>");
                }
            }
        }

        // Orphaned tables
        if (orphaned.Count > 0)
        {
            sb.AppendLine("<details><summary><h3 style=\"display:inline\">Standalone Tables</h3> <span class=\"meta\">(" + orphaned.Count + " tables with no FK relationships)</span></summary><ul>");
            foreach (var dep in orphaned.OrderBy(d => d.FullName))
                sb.AppendLine($"<li>{E(dep.FullName)}</li>");
            sb.AppendLine("</ul></details>");
        }

        sb.AppendLine("</section>");
    }

    private void BuildSchemaSection(StringBuilder sb, AnalysisResult result)
    {
        var schema = result.Schema!;
        sb.AppendLine("<section id=\"schema\">");
        sb.AppendLine("<h2>Schema Overview</h2>");

        sb.AppendLine("<div class=\"summary-grid\">");
        sb.AppendLine($"<div class=\"card\"><h3>{schema.Tables.Count}</h3><p>Tables</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{schema.Views.Count}</h3><p>Views</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{schema.StoredProcedures.Count}</h3><p>Stored Procedures</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{schema.Functions.Count}</h3><p>Functions</p></div>");
        if (schema.Triggers.Count > 0)
            sb.AppendLine($"<div class=\"card\"><h3>{schema.Triggers.Count}</h3><p>Triggers</p></div>");
        if (schema.Synonyms.Count > 0)
            sb.AppendLine($"<div class=\"card\"><h3>{schema.Synonyms.Count}</h3><p>Synonyms</p></div>");
        if (schema.Sequences.Count > 0)
            sb.AppendLine($"<div class=\"card\"><h3>{schema.Sequences.Count}</h3><p>Sequences</p></div>");
        if (schema.UserDefinedTypes.Count > 0)
            sb.AppendLine($"<div class=\"card\"><h3>{schema.UserDefinedTypes.Count}</h3><p>User-Defined Types</p></div>");
        if (schema.Jobs.Count > 0)
            sb.AppendLine($"<div class=\"card\"><h3>{schema.Jobs.Count}</h3><p>SQL Agent Jobs</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{schema.Tables.Sum(t => t.Columns.Count)}</h3><p>Total Columns</p></div>");
        sb.AppendLine("</div>");

        foreach (var table in schema.Tables)
        {
            sb.AppendLine($"<h3 id=\"table-{E(table.FullName)}\">{E(table.FullName)}</h3>");
            sb.AppendLine("<table><thead><tr><th>Column</th><th>Type</th><th>Nullable</th><th>PK</th><th>Identity</th><th>Default</th></tr></thead><tbody>");

            foreach (var col in table.Columns)
            {
                var typeStr = col.MaxLength.HasValue
                    ? $"{col.DataType}({(col.MaxLength == -1 ? "MAX" : col.MaxLength.ToString())})"
                    : col.Precision.HasValue
                        ? $"{col.DataType}({col.Precision},{col.Scale})"
                        : col.DataType;

                sb.AppendLine($"<tr><td>{E(col.Name)}</td><td>{typeStr}</td>");
                sb.AppendLine($"<td>{(col.IsNullable ? "<span class=\"warn\">YES</span>" : "NO")}</td>");
                sb.AppendLine($"<td>{(col.IsPrimaryKey ? "<span class=\"ok\">PK</span>" : "")}</td>");
                sb.AppendLine($"<td>{(col.IsIdentity ? "Yes" : "")}</td>");
                sb.AppendLine($"<td>{E(col.DefaultValue ?? "")}</td></tr>");
            }

            sb.AppendLine("</tbody></table>");

            if (table.Indexes.Count > 0)
            {
                sb.AppendLine("<details><summary>Indexes</summary>");
                sb.AppendLine("<table><thead><tr><th>Name</th><th>Type</th><th>Unique</th><th>Columns</th></tr></thead><tbody>");
                foreach (var idx in table.Indexes)
                {
                    sb.AppendLine($"<tr><td>{E(idx.Name)}</td><td>{idx.Type}</td><td>{(idx.IsUnique ? "Yes" : "No")}</td><td>{E(string.Join(", ", idx.Columns))}</td></tr>");
                }
                sb.AppendLine("</tbody></table></details>");
            }
        }

        // Triggers
        if (schema.Triggers.Count > 0)
        {
            sb.AppendLine("<h3>Triggers</h3>");
            sb.AppendLine("<table><thead><tr><th>Trigger</th><th>Parent Table</th><th>Type</th><th>Events</th><th>Enabled</th></tr></thead><tbody>");
            foreach (var tr in schema.Triggers)
            {
                var enabledLabel = tr.IsEnabled ? "<span class=\"ok\">Yes</span>" : "<span class=\"error\">No</span>";
                sb.AppendLine($"<tr><td>{E(tr.FullName)}</td><td>{E(tr.ParentFullName)}</td><td>{tr.TriggerType}</td><td>{E(tr.TriggerEvents)}</td><td>{enabledLabel}</td></tr>");
            }
            sb.AppendLine("</tbody></table>");
        }

        // Synonyms
        if (schema.Synonyms.Count > 0)
        {
            sb.AppendLine("<h3>Synonyms</h3>");
            sb.AppendLine("<table><thead><tr><th>Synonym</th><th>Base Object</th></tr></thead><tbody>");
            foreach (var syn in schema.Synonyms)
            {
                sb.AppendLine($"<tr><td>{E(syn.FullName)}</td><td>{E(syn.BaseObjectName)}</td></tr>");
            }
            sb.AppendLine("</tbody></table>");
        }

        // Sequences
        if (schema.Sequences.Count > 0)
        {
            sb.AppendLine("<h3>Sequences</h3>");
            sb.AppendLine("<table><thead><tr><th>Sequence</th><th>Data Type</th><th>Current</th><th>Increment</th><th>Min</th><th>Max</th><th>Cycling</th></tr></thead><tbody>");
            foreach (var seq in schema.Sequences)
            {
                sb.AppendLine($"<tr><td>{E(seq.FullName)}</td><td>{seq.DataType}</td><td>{seq.CurrentValue:N0}</td><td>{seq.Increment}</td><td>{seq.MinValue:N0}</td><td>{seq.MaxValue:N0}</td><td>{(seq.IsCycling ? "Yes" : "No")}</td></tr>");
            }
            sb.AppendLine("</tbody></table>");
        }

        // User-Defined Types
        if (schema.UserDefinedTypes.Count > 0)
        {
            sb.AppendLine("<h3>User-Defined Types</h3>");
            sb.AppendLine("<table><thead><tr><th>Type</th><th>Base Type</th><th>Table Type</th><th>Nullable</th><th>Max Length</th></tr></thead><tbody>");
            foreach (var udt in schema.UserDefinedTypes)
            {
                sb.AppendLine($"<tr><td>{E(udt.FullName)}</td><td>{udt.BaseType}</td><td>{(udt.IsTableType ? "Yes" : "No")}</td><td>{(udt.IsNullable ? "Yes" : "No")}</td><td>{(udt.MaxLength.HasValue ? udt.MaxLength.ToString() : "N/A")}</td></tr>");
            }
            sb.AppendLine("</tbody></table>");
        }

        sb.AppendLine("</section>");
    }

    private void BuildProfilingSection(StringBuilder sb, AnalysisResult result)
    {
        sb.AppendLine("<section id=\"profiling\">");
        sb.AppendLine("<h2>Data Profiling</h2>");

        foreach (var profile in result.Profiles!)
        {
            sb.AppendLine($"<h3>{E(profile.FullName)} <span class=\"meta\">({profile.RowCount:N0} rows)</span></h3>");

            if (profile.RowCount == 0)
            {
                sb.AppendLine("<p class=\"meta\">Empty table</p>");
                continue;
            }

            sb.AppendLine("<table><thead><tr><th>Column</th><th>Type</th><th>Null %</th><th>Distinct</th><th>Min</th><th>Max</th></tr></thead><tbody>");

            foreach (var col in profile.ColumnProfiles)
            {
                var nullClass = col.NullPercentage > 50 ? "error" : col.NullPercentage > 0 ? "warn" : "ok";
                sb.AppendLine($"<tr><td>{E(col.ColumnName)}</td><td>{col.DataType}</td>");
                sb.AppendLine($"<td class=\"{nullClass}\">{col.NullPercentage:F1}%</td>");
                sb.AppendLine($"<td>{col.DistinctCount:N0}</td>");
                sb.AppendLine($"<td>{E(Truncate(col.MinValue, 40))}</td>");
                sb.AppendLine($"<td>{E(Truncate(col.MaxValue, 40))}</td></tr>");
            }

            sb.AppendLine("</tbody></table>");
        }

        sb.AppendLine("</section>");
    }

    private void BuildRelationshipsSection(StringBuilder sb, AnalysisResult result)
    {
        var map = result.Relationships!;
        sb.AppendLine("<section id=\"relationships\">");
        sb.AppendLine("<h2>Relationships Detail</h2>");

        if (map.ExplicitRelationships.Count > 0)
        {
            sb.AppendLine("<h3>Explicit Foreign Keys</h3>");
            sb.AppendLine("<table><thead><tr><th>Name</th><th>From</th><th>To</th><th>Delete</th><th>Update</th></tr></thead><tbody>");
            foreach (var fk in map.ExplicitRelationships)
            {
                sb.AppendLine($"<tr><td>{E(fk.Name)}</td>");
                sb.AppendLine($"<td>{E(fk.FromSchema)}.{E(fk.FromTable)}.{E(fk.FromColumn)}</td>");
                sb.AppendLine($"<td>{E(fk.ToSchema)}.{E(fk.ToTable)}.{E(fk.ToColumn)}</td>");
                sb.AppendLine($"<td>{fk.DeleteRule}</td><td>{fk.UpdateRule}</td></tr>");
            }
            sb.AppendLine("</tbody></table>");
        }

        if (map.ViewDependencies.Count > 0)
        {
            sb.AppendLine("<h3>Object Dependencies (Views, Procedures, Functions)</h3>");
            sb.AppendLine("<table><thead><tr><th>Object</th><th>Type</th><th>Depends On</th><th>Target Type</th><th>Database</th></tr></thead><tbody>");
            foreach (var vd in map.ViewDependencies)
            {
                var dbLabel = vd.IsCrossDatabase ? $"<span class=\"error\">{E(vd.ToDatabase!)}</span>" : "<span class=\"meta\">local</span>";
                sb.AppendLine($"<tr><td>{E(vd.FromSchema)}.{E(vd.FromName)}</td><td>{vd.FromType}</td>");
                sb.AppendLine($"<td>{E(vd.ToFullName)}</td><td>{vd.ToType}</td><td>{dbLabel}</td></tr>");
            }
            sb.AppendLine("</tbody></table>");
        }

        if (map.ImplicitRelationships.Count > 0)
        {
            sb.AppendLine("<h3>Implicit (Detected) Relationships</h3>");
            sb.AppendLine("<table><thead><tr><th>From</th><th>To</th><th>Confidence</th><th>Reason</th></tr></thead><tbody>");
            foreach (var rel in map.ImplicitRelationships)
            {
                sb.AppendLine($"<tr><td>{E(rel.FromSchema)}.{E(rel.FromTable)}.{E(rel.FromColumn)}</td>");
                sb.AppendLine($"<td>{E(rel.ToSchema)}.{E(rel.ToTable)}.{E(rel.ToColumn)}</td>");
                sb.AppendLine($"<td>{rel.Confidence:P0}</td><td>{E(rel.Reason)}</td></tr>");
            }
            sb.AppendLine("</tbody></table>");
        }

        sb.AppendLine("</section>");
    }

    private void BuildQualitySection(StringBuilder sb, AnalysisResult result)
    {
        var issues = result.QualityIssues!;
        sb.AppendLine("<section id=\"quality\">");
        sb.AppendLine("<h2>Quality Issues</h2>");

        if (issues.Count == 0)
        {
            sb.AppendLine("<p class=\"ok\">No quality issues found.</p>");
            sb.AppendLine("</section>");
            return;
        }

        var grouped = issues.GroupBy(i => i.Severity).OrderByDescending(g => g.Key);
        foreach (var group in grouped)
        {
            var cssClass = group.Key switch
            {
                IssueSeverity.Error => "error",
                IssueSeverity.Warning => "warn",
                _ => "info"
            };

            sb.AppendLine($"<h3 class=\"{cssClass}\">{group.Key} ({group.Count()})</h3>");
            sb.AppendLine("<table><thead><tr><th>Object</th><th>Category</th><th>Issue</th><th>Recommendation</th></tr></thead><tbody>");
            foreach (var issue in group)
            {
                sb.AppendLine($"<tr><td>{E(issue.ObjectName)}</td><td>{issue.Category}</td>");
                sb.AppendLine($"<td>{E(issue.Description)}</td><td>{E(issue.Recommendation ?? "")}</td></tr>");
            }
            sb.AppendLine("</tbody></table>");
        }

        sb.AppendLine("</section>");
    }

    private static string E(string text) => HttpUtility.HtmlEncode(text);

    private static string Truncate(string? value, int maxLength)
    {
        if (string.IsNullOrEmpty(value)) return "";
        return value.Length <= maxLength ? value : value[..maxLength] + "...";
    }

    private string GetGraphJs(AnalysisResult result)
    {
        var deps = result.Relationships!.Dependencies;
        var fks = result.Relationships!.ExplicitRelationships;
        var viewDeps = result.Relationships!.ViewDependencies;

        // Build nodes array
        var connected = deps.Where(d => d.DirectConnections > 0).ToList();
        var nodeIndex = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
        var nodes = new List<object>();
        for (var i = 0; i < connected.Count; i++)
        {
            var d = connected[i];
            nodeIndex[d.FullName] = i;
            nodes.Add(new
            {
                id = d.FullName,
                label = d.IsExternal ? d.FullName : $"{d.SchemaName}.{d.TableName}",
                type = d.ObjectType.ToLowerInvariant(),
                refBy = d.ReferencedBy.Count,
                depOn = d.DependsOn.Count,
                impact = d.TransitiveImpact.Count,
                score = d.ImportanceScore
            });
        }

        // Build edges (deduplicated at object level)
        var edgeSet = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        var edges = new List<object>();
        foreach (var fk in fks)
        {
            var from = $"{fk.FromSchema}.{fk.FromTable}";
            var to = $"{fk.ToSchema}.{fk.ToTable}";
            var key = $"{from}->{to}";
            if (!edgeSet.Add(key)) continue;
            if (!nodeIndex.ContainsKey(from) || !nodeIndex.ContainsKey(to)) continue;
            edges.Add(new { source = nodeIndex[from], target = nodeIndex[to], type = "fk", fromType = "Table", toType = "Table", label = $"{from} → {to}" });
        }

        // Add object dependency edges (views, procedures, functions, cross-DB)
        foreach (var vd in viewDeps)
        {
            var from = $"{vd.FromSchema}.{vd.FromName}";
            var to = vd.ToFullName;
            var key = $"{from}->{to}";
            if (!edgeSet.Add(key)) continue;
            if (!nodeIndex.ContainsKey(from) || !nodeIndex.ContainsKey(to)) continue;
            var edgeType = vd.IsCrossDatabase ? "external" : vd.FromType.ToLowerInvariant();
            edges.Add(new { source = nodeIndex[from], target = nodeIndex[to], type = edgeType, fromType = vd.FromType, toType = vd.ToType, label = $"{from} → {to}" });
        }

        var nodesJson = JsonSerializer.Serialize(nodes);
        var edgesJson = JsonSerializer.Serialize(edges);

        return $$"""
const graphNodes = {{nodesJson}};
const graphEdges = {{edgesJson}};

(function() {
    const svg = document.getElementById('dep-graph');
    const container = document.getElementById('graph-container');
    const width = container.clientWidth || 1200;
    const height = Math.max(600, Math.min(graphNodes.length * 12, 1000));
    svg.setAttribute('width', width);
    svg.setAttribute('height', height);

    // Zoom/pan state
    let vb = { x: 0, y: 0, w: width, h: height };
    const updateViewBox = () => svg.setAttribute('viewBox', `${vb.x} ${vb.y} ${vb.w} ${vb.h}`);
    updateViewBox();

    // Convert screen coords to world (SVG) coords
    function screenToWorld(sx, sy) {
        const rect = svg.getBoundingClientRect();
        return {
            x: vb.x + (sx - rect.left) / rect.width * vb.w,
            y: vb.y + (sy - rect.top) / rect.height * vb.h
        };
    }

    const maxScore = Math.max(...graphNodes.map(n => n.score), 1);

    // Initialize positions in a circle
    graphNodes.forEach((n, i) => {
        const angle = (2 * Math.PI * i) / graphNodes.length;
        const r = Math.min(width, height) * 0.35;
        n.x = width / 2 + r * Math.cos(angle);
        n.y = height / 2 + r * Math.sin(angle);
        n.vx = 0;
        n.vy = 0;
        n.radius = 6 + (n.score / maxScore) * 20;
    });

    // SVG defs
    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
    marker.setAttribute('id', 'arrow');
    marker.setAttribute('viewBox', '0 0 10 10');
    marker.setAttribute('refX', '10');
    marker.setAttribute('refY', '5');
    marker.setAttribute('markerWidth', '6');
    marker.setAttribute('markerHeight', '6');
    marker.setAttribute('orient', 'auto-start-reverse');
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
    path.setAttribute('fill', '#4fc3f7');
    marker.appendChild(path);
    defs.appendChild(marker);
    svg.appendChild(defs);

    const edgeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const nodeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const labelGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    svg.appendChild(edgeGroup);
    svg.appendChild(nodeGroup);
    svg.appendChild(labelGroup);

    // Tooltip
    const tooltip = document.createElement('div');
    tooltip.className = 'graph-tooltip';
    container.appendChild(tooltip);

    // Zoom controls
    const controls = document.createElement('div');
    controls.className = 'graph-controls';
    controls.innerHTML = '<button id="zoom-in" title="Zoom in">+</button><button id="zoom-out" title="Zoom out">&minus;</button><button id="zoom-fit" title="Fit all">&#8634;</button><button id="dep-reorder" title="Auto-layout (connection-aware)">&#9638;</button><button id="dep-fs" title="Fullscreen">&#x26F6;</button>';
    container.appendChild(controls);

    // Create edge elements
    const edgeColors = { fk: '#4fc3f7', view: '#4ecca3', procedure: '#f0a500', function: '#bb86fc', trigger: '#ff7043', synonym: '#78909c', job: '#26a69a', external: '#ff6b6b' };
    const edgeEls = graphEdges.map((e, i) => {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        const color = edgeColors[e.type] || '#4fc3f7';
        line.setAttribute('stroke', color);
        line.setAttribute('stroke-opacity', '0.4');
        line.setAttribute('stroke-width', '1.5');
        if (e.type !== 'fk') line.setAttribute('stroke-dasharray', '6,3');
        line.setAttribute('marker-end', 'url(#arrow)');
        line.style.cursor = 'pointer';
        edgeGroup.appendChild(line);
        return line;
    });

    // Edge hover tooltips
    edgeEls.forEach((el, i) => {
        const e = graphEdges[i];
        el.addEventListener('mouseenter', (ev) => {
            tooltip.innerHTML = `<strong>${e.fromType} &rarr; ${e.toType}</strong><br>${e.label}`;
            tooltip.style.display = 'block';
            const cr = container.getBoundingClientRect();
            tooltip.style.left = (ev.clientX - cr.left + 15) + 'px';
            tooltip.style.top = (ev.clientY - cr.top - 10) + 'px';
            el.setAttribute('stroke-opacity', '1');
            el.setAttribute('stroke-width', '3');
        });
        el.addEventListener('mousemove', (ev) => {
            const cr = container.getBoundingClientRect();
            tooltip.style.left = (ev.clientX - cr.left + 15) + 'px';
            tooltip.style.top = (ev.clientY - cr.top - 10) + 'px';
        });
        el.addEventListener('mouseleave', () => {
            tooltip.style.display = 'none';
            el.setAttribute('stroke-opacity', '0.4');
            el.setAttribute('stroke-width', '1.5');
        });
    });

    // Create node elements
    const nodeEls = graphNodes.map((n, i) => {
        if (n.type === 'view') {
            const diamond = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            diamond.setAttribute('fill', '#4ecca3');
            diamond.setAttribute('stroke', '#e0e0e0');
            diamond.setAttribute('stroke-width', '1');
            diamond.setAttribute('cursor', 'grab');
            nodeGroup.appendChild(diamond);
            return diamond;
        }
        if (n.type === 'procedure') {
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('fill', '#f0a500');
            rect.setAttribute('stroke', '#e0e0e0');
            rect.setAttribute('stroke-width', '1');
            rect.setAttribute('cursor', 'grab');
            nodeGroup.appendChild(rect);
            return rect;
        }
        if (n.type === 'function') {
            const tri = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            tri.setAttribute('fill', '#bb86fc');
            tri.setAttribute('stroke', '#e0e0e0');
            tri.setAttribute('stroke-width', '1');
            tri.setAttribute('cursor', 'grab');
            nodeGroup.appendChild(tri);
            return tri;
        }
        if (n.type === 'trigger') {
            // Star/bolt shape (rotated diamond with notch)
            const star = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            star.setAttribute('fill', '#ff7043');
            star.setAttribute('stroke', '#e0e0e0');
            star.setAttribute('stroke-width', '1');
            star.setAttribute('cursor', 'grab');
            nodeGroup.appendChild(star);
            return star;
        }
        if (n.type === 'synonym') {
            // Rounded rect (pill shape)
            const pill = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            pill.setAttribute('fill', '#78909c');
            pill.setAttribute('stroke', '#e0e0e0');
            pill.setAttribute('stroke-width', '1');
            pill.setAttribute('cursor', 'grab');
            nodeGroup.appendChild(pill);
            return pill;
        }
        if (n.type === 'job') {
            const hex = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            hex.setAttribute('fill', '#26a69a');
            hex.setAttribute('stroke', '#e0e0e0');
            hex.setAttribute('stroke-width', '1');
            hex.setAttribute('cursor', 'grab');
            nodeGroup.appendChild(hex);
            return hex;
        }
        if (n.type === 'external') {
            const diamond = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            diamond.setAttribute('fill', 'none');
            diamond.setAttribute('stroke', '#ff6b6b');
            diamond.setAttribute('stroke-width', '2');
            diamond.setAttribute('stroke-dasharray', '4,2');
            diamond.setAttribute('cursor', 'grab');
            nodeGroup.appendChild(diamond);
            return diamond;
        }
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('r', n.radius);
        const hue = n.refBy > 0 ? (n.refBy > 5 ? 0 : 30) : 200;
        circle.setAttribute('fill', `hsl(${hue}, 70%, ${50 + (n.score / maxScore) * 20}%)`);
        circle.setAttribute('stroke', '#e0e0e0');
        circle.setAttribute('stroke-width', '1');
        circle.setAttribute('cursor', 'grab');
        nodeGroup.appendChild(circle);
        return circle;
    });

    // Hover/tooltip
    nodeEls.forEach((el, i) => {
        const n = graphNodes[i];
        el.addEventListener('mouseenter', (ev) => {
            tooltip.innerHTML = `<strong>${n.id}</strong><br>Type: ${n.type.charAt(0).toUpperCase() + n.type.slice(1)}<br>Referenced by: ${n.refBy}<br>Depends on: ${n.depOn}<br>Impact: ${n.impact}<br>Score: ${n.score}`;
            tooltip.style.display = 'block';
            const cr = container.getBoundingClientRect();
            tooltip.style.left = (ev.clientX - cr.left + 15) + 'px';
            tooltip.style.top = (ev.clientY - cr.top - 10) + 'px';
            graphEdges.forEach((e, ei) => {
                if (e.source === i || e.target === i) {
                    edgeEls[ei].setAttribute('stroke-opacity', '1');
                    edgeEls[ei].setAttribute('stroke-width', '2.5');
                }
            });
            el.setAttribute('stroke-width', '3');
        });
        el.addEventListener('mouseleave', () => {
            tooltip.style.display = 'none';
            graphEdges.forEach((e, ei) => {
                edgeEls[ei].setAttribute('stroke-opacity', '0.4');
                edgeEls[ei].setAttribute('stroke-width', '1.5');
            });
            el.setAttribute('stroke-width', '1');
        });
    });

    // Labels
    const labelEls = graphNodes.map(n => {
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.textContent = n.label;
        text.setAttribute('font-size', Math.max(9, Math.min(13, 8 + n.radius / 4)));
        text.setAttribute('fill', '#e0e0e0');
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('pointer-events', 'none');
        labelGroup.appendChild(text);
        return text;
    });

    // --- Zoom ---
    function zoomBy(factor, cx, cy) {
        const newW = vb.w / factor, newH = vb.h / factor;
        vb.x = cx - (cx - vb.x) / factor;
        vb.y = cy - (cy - vb.y) / factor;
        vb.w = newW;
        vb.h = newH;
        updateViewBox();
    }

    svg.addEventListener('wheel', (ev) => {
        ev.preventDefault();
        const p = screenToWorld(ev.clientX, ev.clientY);
        const factor = ev.deltaY < 0 ? 1.15 : 1 / 1.15;
        zoomBy(factor, p.x, p.y);
    }, { passive: false });

    document.getElementById('zoom-in').addEventListener('click', () => {
        const cx = vb.x + vb.w / 2, cy = vb.y + vb.h / 2;
        zoomBy(1.3, cx, cy);
    });
    document.getElementById('zoom-out').addEventListener('click', () => {
        const cx = vb.x + vb.w / 2, cy = vb.y + vb.h / 2;
        zoomBy(1 / 1.3, cx, cy);
    });
    function fitAllDep() {
        let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
        graphNodes.forEach((n,i) => {
            if (nodeEls[i].getAttribute('visibility') === 'hidden') return;
            minX=Math.min(minX,n.x-n.radius-20); minY=Math.min(minY,n.y-n.radius-20);
            maxX=Math.max(maxX,n.x+n.radius+20); maxY=Math.max(maxY,n.y+n.radius+20);
        });
        if (minX===Infinity) { vb={x:0,y:0,w:width,h:height}; updateViewBox(); return; }
        const pad=60;
        vb={x:minX-pad, y:minY-pad, w:maxX-minX+pad*2, h:maxY-minY+pad*2};
        updateViewBox();
    }
    document.getElementById('zoom-fit').addEventListener('click', () => { fitAllDep(); });

    // --- Auto-layout (force-directed re-spread) ---
    let simRunning = true;
    document.getElementById('dep-reorder').addEventListener('click', () => {
        const cw = container.clientWidth || 1200;
        const ch = container.clientHeight || 800;
        const area = Math.max(cw, ch) * Math.sqrt(graphNodes.length) * 1.0;
        const cx0 = area / 2, cy0 = area / 2;
        graphNodes.forEach((n, i) => {
            const angle = (2 * Math.PI * i) / graphNodes.length;
            const radius = area * 0.38;
            n.x = cx0 + Math.cos(angle) * radius * (0.8 + Math.random() * 0.4);
            n.y = cy0 + Math.sin(angle) * radius * (0.8 + Math.random() * 0.4);
            n.vx = 0; n.vy = 0;
        });
        simRunning = true;
        setTimeout(() => fitAllDep(), 2000);
    });

    // --- Fullscreen ---
    const depFsBtn = document.getElementById('dep-fs');
    depFsBtn.addEventListener('click', () => {
        if (document.fullscreenElement) {
            document.exitFullscreen();
        } else {
            container.requestFullscreen().catch(() => {});
        }
    });
    document.addEventListener('fullscreenchange', () => {
        if (document.fullscreenElement === container) {
            container.style.height = '100vh';
            container.style.borderRadius = '0';
            svg.setAttribute('width', screen.width);
            svg.setAttribute('height', screen.height);
            depFsBtn.textContent = '\u2716'; depFsBtn.title = 'Exit fullscreen';
        } else if (!document.fullscreenElement || document.fullscreenElement.id !== 'graph-container') {
            container.style.height = '';
            container.style.borderRadius = '';
            svg.setAttribute('width', container.clientWidth || width);
            svg.setAttribute('height', height);
            depFsBtn.textContent = '\u26F6'; depFsBtn.title = 'Fullscreen';
        }
        fitAllDep();
    });

    // --- Drag nodes + Pan ---
    let dragNode = null, dragOffset = {x:0,y:0};
    let isPanning = false, panStart = {x:0,y:0}, vbStart = {x:0,y:0};

    svg.addEventListener('mousedown', (ev) => {
        const p = screenToWorld(ev.clientX, ev.clientY);
        // Check if clicking a node
        for (let i = 0; i < graphNodes.length; i++) {
            const n = graphNodes[i];
            if (Math.hypot(p.x - n.x, p.y - n.y) < n.radius + 5) {
                dragNode = i;
                dragOffset = { x: p.x - n.x, y: p.y - n.y };
                graphNodes[i].fx = n.x;
                graphNodes[i].fy = n.y;
                svg.style.cursor = 'grabbing';
                return;
            }
        }
        // Otherwise start panning
        isPanning = true;
        panStart = { x: ev.clientX, y: ev.clientY };
        vbStart = { x: vb.x, y: vb.y };
        svg.style.cursor = 'move';
    });

    svg.addEventListener('mousemove', (ev) => {
        if (dragNode !== null) {
            const p = screenToWorld(ev.clientX, ev.clientY);
            graphNodes[dragNode].fx = p.x - dragOffset.x;
            graphNodes[dragNode].fy = p.y - dragOffset.y;
        } else if (isPanning) {
            const rect = svg.getBoundingClientRect();
            const dx = (ev.clientX - panStart.x) / rect.width * vb.w;
            const dy = (ev.clientY - panStart.y) / rect.height * vb.h;
            vb.x = vbStart.x - dx;
            vb.y = vbStart.y - dy;
            updateViewBox();
        }
    });

    svg.addEventListener('mouseup', () => {
        if (dragNode !== null) {
            graphNodes[dragNode].x = graphNodes[dragNode].fx;
            graphNodes[dragNode].y = graphNodes[dragNode].fy;
            delete graphNodes[dragNode].fx;
            delete graphNodes[dragNode].fy;
        }
        dragNode = null;
        isPanning = false;
        svg.style.cursor = 'default';
    });

    svg.addEventListener('mouseleave', () => {
        isPanning = false;
        if (dragNode !== null) {
            graphNodes[dragNode].x = graphNodes[dragNode].fx;
            graphNodes[dragNode].y = graphNodes[dragNode].fy;
            delete graphNodes[dragNode].fx;
            delete graphNodes[dragNode].fy;
            dragNode = null;
        }
        svg.style.cursor = 'default';
    });

    // Force simulation
    function tick() {
        const N = graphNodes.length;
        for (let i = 0; i < N; i++) {
            for (let j = i + 1; j < N; j++) {
                let dx = graphNodes[i].x - graphNodes[j].x;
                let dy = graphNodes[i].y - graphNodes[j].y;
                let dist = Math.sqrt(dx*dx + dy*dy) || 1;
                let force = 2500 / (dist * dist);
                let fx = dx / dist * force;
                let fy = dy / dist * force;
                graphNodes[i].vx += fx;
                graphNodes[i].vy += fy;
                graphNodes[j].vx -= fx;
                graphNodes[j].vy -= fy;
            }
        }
        graphEdges.forEach(e => {
            let s = graphNodes[e.source], t = graphNodes[e.target];
            let dx = t.x - s.x, dy = t.y - s.y;
            let dist = Math.sqrt(dx*dx + dy*dy) || 1;
            let force = (dist - 180) * 0.004;
            let fx = dx / dist * force;
            let fy = dy / dist * force;
            s.vx += fx; s.vy += fy;
            t.vx -= fx; t.vy -= fy;
        });
        graphNodes.forEach(n => {
            n.vx += (width/2 - n.x) * 0.0006;
            n.vy += (height/2 - n.y) * 0.0006;
        });
        graphNodes.forEach((n, i) => {
            if (i === dragNode) {
                n.x = n.fx; n.y = n.fy;
                n.vx = 0; n.vy = 0;
                return;
            }
            n.vx *= 0.85;
            n.vy *= 0.85;
            n.x += n.vx;
            n.y += n.vy;
        });
        // Update SVG
        graphEdges.forEach((e, i) => {
            let s = graphNodes[e.source], t = graphNodes[e.target];
            let dx = t.x - s.x, dy = t.y - s.y;
            let dist = Math.sqrt(dx*dx + dy*dy) || 1;
            let offsetS = s.radius / dist, offsetT = t.radius / dist;
            edgeEls[i].setAttribute('x1', s.x + dx * offsetS);
            edgeEls[i].setAttribute('y1', s.y + dy * offsetS);
            edgeEls[i].setAttribute('x2', t.x - dx * offsetT);
            edgeEls[i].setAttribute('y2', t.y - dy * offsetT);
        });
        nodeEls.forEach((el, i) => {
            const n = graphNodes[i];
            if (n.type === 'view') {
                const r = n.radius;
                el.setAttribute('points', `${n.x},${n.y-r} ${n.x+r},${n.y} ${n.x},${n.y+r} ${n.x-r},${n.y}`);
            } else if (n.type === 'procedure') {
                const r = n.radius;
                el.setAttribute('x', n.x - r);
                el.setAttribute('y', n.y - r);
                el.setAttribute('width', r * 2);
                el.setAttribute('height', r * 2);
                el.setAttribute('rx', '3');
            } else if (n.type === 'function') {
                const r = n.radius;
                el.setAttribute('points', `${n.x},${n.y-r} ${n.x+r},${n.y+r} ${n.x-r},${n.y+r}`);
            } else if (n.type === 'trigger') {
                const r = n.radius;
                // 5-point star
                let pts = '';
                for (let k = 0; k < 5; k++) {
                    const outerAngle = (Math.PI * 2 * k / 5) - Math.PI / 2;
                    const innerAngle = outerAngle + Math.PI / 5;
                    pts += `${n.x + r * Math.cos(outerAngle)},${n.y + r * Math.sin(outerAngle)} `;
                    pts += `${n.x + r * 0.45 * Math.cos(innerAngle)},${n.y + r * 0.45 * Math.sin(innerAngle)} `;
                }
                el.setAttribute('points', pts.trim());
            } else if (n.type === 'synonym') {
                const r = n.radius;
                el.setAttribute('x', n.x - r * 1.3);
                el.setAttribute('y', n.y - r * 0.7);
                el.setAttribute('width', r * 2.6);
                el.setAttribute('height', r * 1.4);
                el.setAttribute('rx', r * 0.7);
            } else if (n.type === 'job') {
                const r = n.radius;
                const a = Math.PI / 3;
                let pts = '';
                for (let k = 0; k < 6; k++) {
                    const angle = a * k - Math.PI / 6;
                    pts += `${n.x + r * Math.cos(angle)},${n.y + r * Math.sin(angle)} `;
                }
                el.setAttribute('points', pts.trim());
            } else if (n.type === 'external') {
                const r = n.radius;
                el.setAttribute('points', `${n.x},${n.y-r} ${n.x+r},${n.y} ${n.x},${n.y+r} ${n.x-r},${n.y}`);
            } else {
                el.setAttribute('cx', n.x);
                el.setAttribute('cy', n.y);
            }
        });
        labelEls.forEach((el, i) => {
            el.setAttribute('x', graphNodes[i].x);
            el.setAttribute('y', graphNodes[i].y + graphNodes[i].radius + 14);
        });
        requestAnimationFrame(tick);
    }
    tick();

    // --- Filtering ---
    const hiddenNodeTypes = new Set();
    const hiddenEdgeTypes = new Set();

    function applyFilters() {
        graphNodes.forEach((n, i) => {
            const vis = !hiddenNodeTypes.has(n.type);
            nodeEls[i].setAttribute('visibility', vis ? 'visible' : 'hidden');
            labelEls[i].setAttribute('visibility', vis ? 'visible' : 'hidden');
        });
        graphEdges.forEach((e, i) => {
            const sVis = !hiddenNodeTypes.has(graphNodes[e.source].type);
            const tVis = !hiddenNodeTypes.has(graphNodes[e.target].type);
            const edgeVis = !hiddenEdgeTypes.has(e.type);
            edgeEls[i].setAttribute('visibility', (sVis && tVis && edgeVis) ? 'visible' : 'hidden');
        });
    }

    window.toggleNodeFilter = function(cb) {
        if (cb.checked) hiddenNodeTypes.delete(cb.value);
        else hiddenNodeTypes.add(cb.value);
        applyFilters();
    };

    window.toggleEdgeFilter = function(cb) {
        if (cb.checked) hiddenEdgeTypes.delete(cb.value);
        else hiddenEdgeTypes.add(cb.value);
        applyFilters();
    };
})();
""";
    }

    private void BuildErdSection(StringBuilder sb, AnalysisResult result)
    {
        var schema = result.Schema!;
        var fkCount = schema.Tables.Sum(t => t.ForeignKeys.Count);
        var depCount = result.Relationships?.ViewDependencies.Count ?? 0;

        sb.AppendLine("<section id=\"erd\">");
        sb.AppendLine("<h2>Entity Relationship Diagram</h2>");
        sb.AppendLine($"<p class=\"meta\">{schema.Tables.Count} tables, {schema.Views.Count} views, {schema.StoredProcedures.Count} procedures, {schema.Functions.Count} functions, {fkCount} FK constraints, {depCount} dependencies. Scroll to zoom. Drag to pan/rearrange.</p>");

        // Filters
        sb.AppendLine("<div class=\"graph-filters\">");
        sb.AppendLine("<span class=\"meta\">Show:</span>");
        sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#e94560\"><input type=\"checkbox\" value=\"table\" checked onchange=\"toggleErdFilter(this)\"><span>Tables ({schema.Tables.Count})</span></label>");
        sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#4ecca3\"><input type=\"checkbox\" value=\"view\" checked onchange=\"toggleErdFilter(this)\"><span>Views ({schema.Views.Count})</span></label>");
        if (schema.StoredProcedures.Count > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#f0a500\"><input type=\"checkbox\" value=\"procedure\" checked onchange=\"toggleErdFilter(this)\"><span>Procedures ({schema.StoredProcedures.Count})</span></label>");
        if (schema.Functions.Count > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#bb86fc\"><input type=\"checkbox\" value=\"function\" checked onchange=\"toggleErdFilter(this)\"><span>Functions ({schema.Functions.Count})</span></label>");
        if (schema.Triggers.Count > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#ff7043\"><input type=\"checkbox\" value=\"trigger\" checked onchange=\"toggleErdFilter(this)\"><span>Triggers ({schema.Triggers.Count})</span></label>");
        if (schema.Synonyms.Count > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#78909c\"><input type=\"checkbox\" value=\"synonym\" checked onchange=\"toggleErdFilter(this)\"><span>Synonyms ({schema.Synonyms.Count})</span></label>");
        sb.AppendLine("</div>");

        sb.AppendLine("<div id=\"erd-container\"><svg id=\"erd-svg\"></svg></div>");
        sb.AppendLine("</section>");
    }

    private string GetErdJs(AnalysisResult result)
    {
        var schema = result.Schema!;

        string ColType(ColumnInfo c)
        {
            if (c.MaxLength.HasValue)
                return $"{c.DataType}({(c.MaxLength == -1 ? "MAX" : c.MaxLength.ToString())})";
            if (c.Precision.HasValue)
                return $"{c.DataType}({c.Precision},{c.Scale})";
            return c.DataType;
        }

        // Build ERD boxes for all object types
        var boxes = new List<object>();

        // Tables
        foreach (var t in schema.Tables)
        {
            var cols = t.Columns.Select(c =>
            {
                var fk = t.ForeignKeys.FirstOrDefault(f =>
                    string.Equals(f.FromColumn, c.Name, StringComparison.OrdinalIgnoreCase));
                return new { name = c.Name, type = ColType(c), pk = c.IsPrimaryKey, fk = fk is not null, nullable = c.IsNullable };
            }).ToList<object>();
            boxes.Add(new { fullName = t.FullName, objType = "table", label = t.FullName, columns = cols, subtitle = "" });
        }

        // Views (with columns)
        foreach (var v in schema.Views)
        {
            var cols = v.Columns.Select(c =>
                new { name = c.Name, type = ColType(c), pk = false, fk = false, nullable = c.IsNullable }
            ).ToList<object>();
            boxes.Add(new { fullName = v.FullName, objType = "view", label = v.FullName, columns = cols, subtitle = "VIEW" });
        }

        // Stored Procedures (no columns, just name)
        foreach (var sp in schema.StoredProcedures)
        {
            var modified = sp.LastModified?.ToString("yyyy-MM-dd") ?? "";
            boxes.Add(new { fullName = sp.FullName, objType = "procedure", label = sp.FullName, columns = new List<object>(), subtitle = modified });
        }

        // Functions
        foreach (var fn in schema.Functions)
        {
            var modified = fn.LastModified?.ToString("yyyy-MM-dd") ?? "";
            boxes.Add(new { fullName = fn.FullName, objType = "function", label = fn.FullName, columns = new List<object>(), subtitle = fn.FunctionType });
        }

        // Triggers
        foreach (var tr in schema.Triggers)
        {
            boxes.Add(new { fullName = tr.FullName, objType = "trigger", label = tr.FullName, columns = new List<object>(), subtitle = $"{tr.TriggerType} {tr.TriggerEvents}" });
        }

        // Synonyms
        foreach (var syn in schema.Synonyms)
        {
            boxes.Add(new { fullName = syn.FullName, objType = "synonym", label = syn.FullName, columns = new List<object>(), subtitle = syn.BaseObjectName });
        }

        // Build FK edges
        var fks = new List<object>();
        foreach (var t in schema.Tables)
        {
            foreach (var fk in t.ForeignKeys)
            {
                fks.Add(new
                {
                    name = fk.Name,
                    fromTable = $"{fk.FromSchema}.{fk.FromTable}",
                    fromCol = fk.FromColumn,
                    toTable = $"{fk.ToSchema}.{fk.ToTable}",
                    toCol = fk.ToColumn,
                    deleteRule = fk.DeleteRule,
                    updateRule = fk.UpdateRule,
                    edgeType = "fk"
                });
            }
        }

        // Build object dependency edges
        var deps = new List<object>();
        if (result.Relationships?.ViewDependencies is not null)
        {
            var seen = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
            foreach (var vd in result.Relationships.ViewDependencies)
            {
                if (vd.IsCrossDatabase) continue;
                var key = $"{vd.FromSchema}.{vd.FromName}->{vd.ToSchema}.{vd.ToName}";
                if (!seen.Add(key)) continue;
                deps.Add(new
                {
                    fromObj = $"{vd.FromSchema}.{vd.FromName}",
                    fromType = vd.FromType,
                    toObj = $"{vd.ToSchema}.{vd.ToName}",
                    toType = vd.ToType,
                    edgeType = vd.FromType.ToLowerInvariant()
                });
            }
        }

        var boxesJson = JsonSerializer.Serialize(boxes);
        var fksJson = JsonSerializer.Serialize(fks);
        var depsJson = JsonSerializer.Serialize(deps);

        return $$"""
const erdBoxes = {{boxesJson}};
const erdFks = {{fksJson}};
const erdDeps = {{depsJson}};

(function() {
    const svg = document.getElementById('erd-svg');
    const container = document.getElementById('erd-container');
    const W = container.clientWidth || 1400;
    const COL_W = 230, HDR_H = 32, ROW_H = 22, PAD = 8, GAP = 40, SUB_H = 18;
    const typeColors = { table:'#0f3460', view:'#1a5c45', procedure:'#5c3d00', function:'#3d1f6d', trigger:'#5c2310', synonym:'#37474f' };
    const titleColors = { table:'#e94560', view:'#4ecca3', procedure:'#f0a500', function:'#bb86fc', trigger:'#ff7043', synonym:'#78909c' };
    const edgeColors = { fk:'#4fc3f7', view:'#4ecca3', procedure:'#f0a500', function:'#bb86fc', trigger:'#ff7043', synonym:'#78909c' };

    // Compute box sizes
    erdBoxes.forEach(b => {
        b.w = COL_W;
        const rows = b.columns.length;
        const sub = b.subtitle ? SUB_H : 0;
        b.h = rows > 0 ? HDR_H + rows * ROW_H + PAD : HDR_H + sub + PAD + 4;
    });

    // Grid layout — group by type
    const typeOrder = ['table','view','procedure','function','trigger','synonym'];
    const sorted = [...erdBoxes.keys()].sort((a,b) => {
        const ta = typeOrder.indexOf(erdBoxes[a].objType), tb = typeOrder.indexOf(erdBoxes[b].objType);
        return ta - tb || a - b;
    });
    const gridCols = Math.max(1, Math.floor((W - GAP) / (COL_W + GAP)));
    let maxRowH = 0, cx = GAP, cy = GAP;
    sorted.forEach((idx, si) => {
        const b = erdBoxes[idx];
        if (cx + b.w > W - GAP) { cx = GAP; cy += maxRowH + GAP; maxRowH = 0; }
        b.x = cx; b.y = cy;
        maxRowH = Math.max(maxRowH, b.h);
        cx += b.w + GAP;
    });

    const totalH = Math.max(800, cy + maxRowH + GAP * 2);
    svg.setAttribute('width', W);
    svg.setAttribute('height', totalH);

    let vb = { x: 0, y: 0, w: W, h: totalH };
    const updateVB = () => svg.setAttribute('viewBox', `${vb.x} ${vb.y} ${vb.w} ${vb.h}`);
    updateVB();
    function s2w(sx, sy) { const r = svg.getBoundingClientRect(); return { x: vb.x + (sx-r.left)/r.width*vb.w, y: vb.y + (sy-r.top)/r.height*vb.h }; }

    // Defs
    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    // Crow's foot "one"
    const mOne = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
    mOne.setAttribute('id','erd-one'); mOne.setAttribute('viewBox','0 0 10 10');
    mOne.setAttribute('refX','10'); mOne.setAttribute('refY','5');
    mOne.setAttribute('markerWidth','8'); mOne.setAttribute('markerHeight','8'); mOne.setAttribute('orient','auto');
    const op = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    op.setAttribute('d','M 10 0 L 10 10 M 6 0 L 6 10');
    op.setAttribute('stroke','#4fc3f7'); op.setAttribute('fill','none'); op.setAttribute('stroke-width','1.5');
    mOne.appendChild(op); defs.appendChild(mOne);
    // Crow's foot "many"
    const mMany = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
    mMany.setAttribute('id','erd-many'); mMany.setAttribute('viewBox','0 0 12 12');
    mMany.setAttribute('refX','0'); mMany.setAttribute('refY','6');
    mMany.setAttribute('markerWidth','10'); mMany.setAttribute('markerHeight','10'); mMany.setAttribute('orient','auto');
    const mp = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    mp.setAttribute('d','M 0 6 L 12 0 M 0 6 L 12 6 M 0 6 L 12 12');
    mp.setAttribute('stroke','#4fc3f7'); mp.setAttribute('fill','none'); mp.setAttribute('stroke-width','1.5');
    mMany.appendChild(mp); defs.appendChild(mMany);
    // Dep arrow
    const mArr = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
    mArr.setAttribute('id','erd-arrow'); mArr.setAttribute('viewBox','0 0 10 10');
    mArr.setAttribute('refX','10'); mArr.setAttribute('refY','5');
    mArr.setAttribute('markerWidth','6'); mArr.setAttribute('markerHeight','6'); mArr.setAttribute('orient','auto');
    const ap = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    ap.setAttribute('d','M 0 0 L 10 5 L 0 10 z'); ap.setAttribute('fill','#888');
    mArr.appendChild(ap); defs.appendChild(mArr);
    svg.appendChild(defs);

    const lineGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const boxGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    svg.appendChild(lineGroup); svg.appendChild(boxGroup);

    const tip = document.createElement('div'); tip.className = 'graph-tooltip'; container.appendChild(tip);
    const ctrl = document.createElement('div'); ctrl.className = 'graph-controls';
    ctrl.innerHTML = '<button id="erd-zi" title="Zoom in">+</button><button id="erd-zo" title="Zoom out">&minus;</button><button id="erd-zr" title="Fit all">&#8634;</button><button id="erd-reorder" title="Auto-layout (connection-aware)">&#9638;</button><button id="erd-fs" title="Fullscreen">&#x26F6;</button>';
    container.appendChild(ctrl);

    const boxIdx = {};
    erdBoxes.forEach((b, i) => boxIdx[b.fullName] = i);

    // Draw boxes
    const boxGroups = erdBoxes.map((b, bi) => {
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.style.cursor = 'grab';
        b._g = g;

        const hdrColor = typeColors[b.objType] || '#0f3460';
        const tColor = titleColors[b.objType] || '#e94560';

        // Background
        const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        bg.setAttribute('width', b.w); bg.setAttribute('height', b.h);
        bg.setAttribute('fill', '#16213e'); bg.setAttribute('stroke', hdrColor);
        bg.setAttribute('stroke-width', '2'); bg.setAttribute('rx', '6');
        g.appendChild(bg);

        // Header bar
        const hdr = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        hdr.setAttribute('width', b.w); hdr.setAttribute('height', HDR_H);
        hdr.setAttribute('fill', hdrColor); hdr.setAttribute('rx', '6');
        g.appendChild(hdr);
        const hdr2 = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        hdr2.setAttribute('y', HDR_H - 6); hdr2.setAttribute('width', b.w); hdr2.setAttribute('height', 6);
        hdr2.setAttribute('fill', hdrColor);
        g.appendChild(hdr2);

        // Type badge (small text in top-right)
        if (b.objType !== 'table') {
            const badge = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            badge.textContent = b.objType.toUpperCase();
            badge.setAttribute('x', b.w - 6); badge.setAttribute('y', 12);
            badge.setAttribute('text-anchor', 'end');
            badge.setAttribute('fill', tColor); badge.setAttribute('font-size', '8');
            badge.setAttribute('opacity', '0.7');
            g.appendChild(badge);
        }

        // Title
        const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        title.textContent = b.label;
        title.setAttribute('x', b.w / 2); title.setAttribute('y', b.objType !== 'table' ? HDR_H / 2 + 8 : HDR_H / 2 + 5);
        title.setAttribute('text-anchor', 'middle');
        title.setAttribute('fill', tColor); title.setAttribute('font-weight', 'bold');
        title.setAttribute('font-size', '11');
        g.appendChild(title);

        if (b.columns.length > 0) {
            // Columns (tables & views)
            b.columns.forEach((c, ci) => {
                const ry = HDR_H + ci * ROW_H + ROW_H / 2 + 5;
                let icon = '';
                if (c.pk && c.fk) icon = 'PF';
                else if (c.pk) icon = 'PK';
                else if (c.fk) icon = 'FK';
                if (icon) {
                    const ic = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    ic.textContent = icon;
                    ic.setAttribute('x', 8); ic.setAttribute('y', ry);
                    ic.setAttribute('fill', c.pk ? '#4ecca3' : '#f0a500');
                    ic.setAttribute('font-size', '9'); ic.setAttribute('font-weight', 'bold');
                    g.appendChild(ic);
                }
                const nm = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                nm.textContent = c.name;
                nm.setAttribute('x', 32); nm.setAttribute('y', ry);
                nm.setAttribute('fill', c.pk ? '#4ecca3' : c.fk ? '#f0a500' : '#e0e0e0');
                nm.setAttribute('font-size', '11');
                if (c.pk) nm.setAttribute('font-weight', 'bold');
                g.appendChild(nm);
                const tp = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                tp.textContent = c.type + (c.nullable ? '' : ' *');
                tp.setAttribute('x', b.w - 8); tp.setAttribute('y', ry);
                tp.setAttribute('text-anchor', 'end');
                tp.setAttribute('fill', '#888'); tp.setAttribute('font-size', '10');
                g.appendChild(tp);
            });
        } else if (b.subtitle) {
            // Subtitle for procs/functions/triggers/synonyms
            const sub = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            sub.textContent = b.subtitle.length > 35 ? b.subtitle.substring(0, 35) + '...' : b.subtitle;
            sub.setAttribute('x', b.w / 2); sub.setAttribute('y', HDR_H + SUB_H / 2 + 5);
            sub.setAttribute('text-anchor', 'middle');
            sub.setAttribute('fill', '#888'); sub.setAttribute('font-size', '10');
            g.appendChild(sub);
        }

        g.setAttribute('transform', `translate(${b.x},${b.y})`);
        boxGroup.appendChild(g);
        return g;
    });

    function colY(box, colName) {
        const ci = box.columns.findIndex(c => c.name.toLowerCase() === colName.toLowerCase());
        if (ci < 0) return box.y + box.h / 2;
        return box.y + HDR_H + ci * ROW_H + ROW_H / 2;
    }
    function midY(box) { return box.y + box.h / 2; }

    function bezier(fromB, fy, toB, ty) {
        const fcx = fromB.x + fromB.w / 2, tcx = toB.x + toB.w / 2;
        let fx, tx, cx1, cx2;
        if (fcx < tcx) { fx = fromB.x + fromB.w; tx = toB.x; }
        else if (fcx > tcx) { fx = fromB.x; tx = toB.x + toB.w; }
        else { fx = fromB.x + fromB.w; tx = toB.x + toB.w; }
        const gap = Math.abs(tx - fx);
        cx1 = fx + (fx < tx ? 1 : -1) * Math.max(30, gap * 0.4);
        cx2 = tx + (tx < fx ? 1 : -1) * Math.max(30, gap * 0.4);
        return `M ${fx} ${fy} C ${cx1} ${fy}, ${cx2} ${ty}, ${tx} ${ty}`;
    }

    // Draw FK lines
    const allLines = [];
    erdFks.forEach(fk => {
        const fi = boxIdx[fk.fromTable], ti = boxIdx[fk.toTable];
        if (fi === undefined || ti === undefined) return;
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('fill', 'none'); path.setAttribute('stroke', '#4fc3f7');
        path.setAttribute('stroke-width', '1.5'); path.setAttribute('stroke-opacity', '0.6');
        path.setAttribute('marker-start', 'url(#erd-many)'); path.setAttribute('marker-end', 'url(#erd-one)');
        path.style.cursor = 'pointer';
        lineGroup.appendChild(path);
        path.addEventListener('mouseenter', (ev) => {
            tip.innerHTML = `<strong>FK: ${fk.name}</strong><br>${fk.fromTable}.${fk.fromCol} &rarr; ${fk.toTable}.${fk.toCol}<br>Delete: ${fk.deleteRule} | Update: ${fk.updateRule}`;
            tip.style.display = 'block'; const cr = container.getBoundingClientRect();
            tip.style.left = (ev.clientX-cr.left+15)+'px'; tip.style.top = (ev.clientY-cr.top-10)+'px';
            path.setAttribute('stroke-opacity','1'); path.setAttribute('stroke-width','3');
        });
        path.addEventListener('mousemove', (ev) => { const cr = container.getBoundingClientRect(); tip.style.left=(ev.clientX-cr.left+15)+'px'; tip.style.top=(ev.clientY-cr.top-10)+'px'; });
        path.addEventListener('mouseleave', () => { tip.style.display='none'; path.setAttribute('stroke-opacity','0.6'); path.setAttribute('stroke-width','1.5'); });
        allLines.push({ el: path, kind: 'fk', fromIdx: fi, toIdx: ti, fromCol: fk.fromCol, toCol: fk.toCol });
    });

    // Draw dependency lines
    erdDeps.forEach(dep => {
        const fi = boxIdx[dep.fromObj], ti = boxIdx[dep.toObj];
        if (fi === undefined || ti === undefined) return;
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        const color = edgeColors[dep.edgeType] || '#888';
        path.setAttribute('fill', 'none'); path.setAttribute('stroke', color);
        path.setAttribute('stroke-width', '1.2'); path.setAttribute('stroke-opacity', '0.5');
        path.setAttribute('stroke-dasharray', '6,3');
        path.setAttribute('marker-end', 'url(#erd-arrow)');
        path.style.cursor = 'pointer';
        lineGroup.appendChild(path);
        path.addEventListener('mouseenter', (ev) => {
            tip.innerHTML = `<strong>${dep.fromType} &rarr; ${dep.toType}</strong><br>${dep.fromObj} &rarr; ${dep.toObj}`;
            tip.style.display = 'block'; const cr = container.getBoundingClientRect();
            tip.style.left = (ev.clientX-cr.left+15)+'px'; tip.style.top = (ev.clientY-cr.top-10)+'px';
            path.setAttribute('stroke-opacity','1'); path.setAttribute('stroke-width','2.5');
        });
        path.addEventListener('mousemove', (ev) => { const cr = container.getBoundingClientRect(); tip.style.left=(ev.clientX-cr.left+15)+'px'; tip.style.top=(ev.clientY-cr.top-10)+'px'; });
        path.addEventListener('mouseleave', () => { tip.style.display='none'; path.setAttribute('stroke-opacity','0.5'); path.setAttribute('stroke-width','1.2'); });
        allLines.push({ el: path, kind: 'dep', edgeType: dep.edgeType, fromIdx: fi, toIdx: ti });
    });

    function updateLines() {
        allLines.forEach(ln => {
            const fromB = erdBoxes[ln.fromIdx], toB = erdBoxes[ln.toIdx];
            const fy = ln.fromCol ? colY(fromB, ln.fromCol) : midY(fromB);
            const ty = ln.toCol ? colY(toB, ln.toCol) : midY(toB);
            ln.el.setAttribute('d', bezier(fromB, fy, toB, ty));
        });
    }
    updateLines();

    // --- Drag & Pan ---
    let dragBox = null, dragOff = {x:0,y:0};
    let isPanning = false, panStart = {x:0,y:0}, vbStart = {x:0,y:0};

    svg.addEventListener('mousedown', (ev) => {
        const p = s2w(ev.clientX, ev.clientY);
        for (let i = 0; i < erdBoxes.length; i++) {
            const b = erdBoxes[i];
            if (b._g.getAttribute('visibility') === 'hidden') continue;
            if (p.x >= b.x && p.x <= b.x + b.w && p.y >= b.y && p.y <= b.y + b.h) {
                dragBox = i; dragOff = {x: p.x - b.x, y: p.y - b.y};
                svg.style.cursor = 'grabbing'; return;
            }
        }
        isPanning = true; panStart = {x:ev.clientX,y:ev.clientY}; vbStart = {x:vb.x,y:vb.y};
        svg.style.cursor = 'move';
    });
    svg.addEventListener('mousemove', (ev) => {
        if (dragBox !== null) {
            const p = s2w(ev.clientX, ev.clientY);
            erdBoxes[dragBox].x = p.x - dragOff.x; erdBoxes[dragBox].y = p.y - dragOff.y;
            boxGroups[dragBox].setAttribute('transform', `translate(${erdBoxes[dragBox].x},${erdBoxes[dragBox].y})`);
            updateLines();
        } else if (isPanning) {
            const r = svg.getBoundingClientRect();
            vb.x = vbStart.x - (ev.clientX-panStart.x)/r.width*vb.w;
            vb.y = vbStart.y - (ev.clientY-panStart.y)/r.height*vb.h;
            updateVB();
        }
    });
    svg.addEventListener('mouseup', () => { dragBox=null; isPanning=false; svg.style.cursor='default'; });
    svg.addEventListener('mouseleave', () => { dragBox=null; isPanning=false; svg.style.cursor='default'; });

    // --- Zoom ---
    function zoomBy(f,cx,cy) { const nw=vb.w/f,nh=vb.h/f; vb.x=cx-(cx-vb.x)/f; vb.y=cy-(cy-vb.y)/f; vb.w=nw;vb.h=nh; updateVB(); }
    svg.addEventListener('wheel', (ev) => { ev.preventDefault(); const p=s2w(ev.clientX,ev.clientY); zoomBy(ev.deltaY<0?1.15:1/1.15,p.x,p.y); }, {passive:false});
    document.getElementById('erd-zi').addEventListener('click', () => { zoomBy(1.3,vb.x+vb.w/2,vb.y+vb.h/2); });
    document.getElementById('erd-zo').addEventListener('click', () => { zoomBy(1/1.3,vb.x+vb.w/2,vb.y+vb.h/2); });
    document.getElementById('erd-zr').addEventListener('click', () => { fitAll(); });

    function fitAll() {
        let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
        erdBoxes.forEach(b => {
            if (b._g.getAttribute('visibility') === 'hidden') return;
            minX=Math.min(minX,b.x); minY=Math.min(minY,b.y);
            maxX=Math.max(maxX,b.x+b.w); maxY=Math.max(maxY,b.y+b.h);
        });
        if (minX===Infinity) { vb={x:0,y:0,w:W,h:totalH}; updateVB(); return; }
        const pad=40;
        vb={x:minX-pad, y:minY-pad, w:maxX-minX+pad*2, h:maxY-minY+pad*2};
        updateVB();
    }

    // --- Auto-layout (connection-aware force-directed) ---
    document.getElementById('erd-reorder').addEventListener('click', () => {
        const cw = container.clientWidth || 1400;
        const ch = container.clientHeight || 800;
        const visible = [];
        erdBoxes.forEach((b,i) => { if (b._g.getAttribute('visibility') !== 'hidden') visible.push(i); });
        if (visible.length === 0) return;

        // Build adjacency from lines
        const adj = new Map();
        visible.forEach(i => adj.set(i, new Set()));
        allLines.forEach(ln => {
            if (adj.has(ln.fromIdx) && adj.has(ln.toIdx)) {
                adj.get(ln.fromIdx).add(ln.toIdx);
                adj.get(ln.toIdx).add(ln.fromIdx);
            }
        });

        // Init positions — spread across available area
        const area = Math.max(cw, ch) * Math.sqrt(visible.length) * 0.7;
        const cx0 = area / 2, cy0 = area / 2;
        visible.forEach((idx, i) => {
            const angle = (2 * Math.PI * i) / visible.length;
            const radius = area * 0.35;
            erdBoxes[idx].x = cx0 + Math.cos(angle) * radius;
            erdBoxes[idx].y = cy0 + Math.sin(angle) * radius;
        });

        // Force-directed simulation
        const ITERATIONS = 200;
        const REPULSION = 80000;
        const ATTRACTION = 0.003;
        const DAMPING = 0.9;
        const MIN_DIST = 50;

        const vel = {};
        visible.forEach(i => { vel[i] = {x:0, y:0}; });

        for (let iter = 0; iter < ITERATIONS; iter++) {
            const temp = 1 - iter / ITERATIONS; // cooling
            const forces = {};
            visible.forEach(i => { forces[i] = {x:0, y:0}; });

            // Repulsion between all pairs
            for (let ai = 0; ai < visible.length; ai++) {
                for (let bi = ai+1; bi < visible.length; bi++) {
                    const a = visible[ai], b = visible[bi];
                    const ba = erdBoxes[a], bb = erdBoxes[b];
                    let dx = (ba.x + ba.w/2) - (bb.x + bb.w/2);
                    let dy = (ba.y + ba.h/2) - (bb.y + bb.h/2);
                    const dist = Math.max(MIN_DIST, Math.sqrt(dx*dx + dy*dy));
                    const f = REPULSION / (dist * dist);
                    const fx = (dx/dist) * f, fy = (dy/dist) * f;
                    forces[a].x += fx; forces[a].y += fy;
                    forces[b].x -= fx; forces[b].y -= fy;
                }
            }

            // Attraction along edges
            allLines.forEach(ln => {
                if (!adj.has(ln.fromIdx) || !adj.has(ln.toIdx)) return;
                const ba = erdBoxes[ln.fromIdx], bb = erdBoxes[ln.toIdx];
                const dx = (bb.x + bb.w/2) - (ba.x + ba.w/2);
                const dy = (bb.y + bb.h/2) - (ba.y + ba.h/2);
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < 1) return;
                const idealDist = 300;
                const f = ATTRACTION * (dist - idealDist);
                const fx = (dx/dist) * f, fy = (dy/dist) * f;
                forces[ln.fromIdx].x += fx; forces[ln.fromIdx].y += fy;
                forces[ln.toIdx].x -= fx; forces[ln.toIdx].y -= fy;
            });

            // Apply forces with damping and cooling
            visible.forEach(i => {
                vel[i].x = (vel[i].x + forces[i].x) * DAMPING * temp;
                vel[i].y = (vel[i].y + forces[i].y) * DAMPING * temp;
                const maxV = 50 * temp;
                const speed = Math.sqrt(vel[i].x*vel[i].x + vel[i].y*vel[i].y);
                if (speed > maxV) { vel[i].x *= maxV/speed; vel[i].y *= maxV/speed; }
                erdBoxes[i].x += vel[i].x;
                erdBoxes[i].y += vel[i].y;
            });

            // Prevent box overlap — push apart
            const OVERLAP_GAP = GAP;
            for (let ai = 0; ai < visible.length; ai++) {
                for (let bi = ai+1; bi < visible.length; bi++) {
                    const a = visible[ai], b = visible[bi];
                    const ba = erdBoxes[a], bb = erdBoxes[b];
                    const ox = (ba.w/2 + bb.w/2 + OVERLAP_GAP) - Math.abs((ba.x+ba.w/2)-(bb.x+bb.w/2));
                    const oy = (ba.h/2 + bb.h/2 + OVERLAP_GAP) - Math.abs((ba.y+ba.h/2)-(bb.y+bb.h/2));
                    if (ox > 0 && oy > 0) {
                        if (ox < oy) {
                            const push = ox / 2 + 1;
                            if (ba.x < bb.x) { ba.x -= push; bb.x += push; }
                            else { ba.x += push; bb.x -= push; }
                        } else {
                            const push = oy / 2 + 1;
                            if (ba.y < bb.y) { ba.y -= push; bb.y += push; }
                            else { ba.y += push; bb.y -= push; }
                        }
                    }
                }
            }
        }

        // Shift so top-left is at GAP,GAP
        let minX=Infinity, minY=Infinity;
        visible.forEach(i => { minX=Math.min(minX,erdBoxes[i].x); minY=Math.min(minY,erdBoxes[i].y); });
        visible.forEach(i => { erdBoxes[i].x -= minX - GAP; erdBoxes[i].y -= minY - GAP; });

        // Update SVG
        visible.forEach(i => {
            boxGroups[i].setAttribute('transform', `translate(${erdBoxes[i].x},${erdBoxes[i].y})`);
        });
        updateLines();
        fitAll();
    });

    // --- Fullscreen ---
    const fsBtn = document.getElementById('erd-fs');
    fsBtn.addEventListener('click', () => {
        if (document.fullscreenElement) {
            document.exitFullscreen();
        } else {
            container.requestFullscreen().catch(() => {});
        }
    });
    document.addEventListener('fullscreenchange', () => {
        if (document.fullscreenElement === container) {
            container.style.height = '100vh';
            container.style.borderRadius = '0';
            svg.setAttribute('width', screen.width);
            svg.setAttribute('height', screen.height);
            fsBtn.textContent = '\u2716'; fsBtn.title = 'Exit fullscreen';
        } else {
            container.style.height = '';
            container.style.borderRadius = '';
            svg.setAttribute('width', container.clientWidth || W);
            svg.setAttribute('height', totalH);
            fsBtn.textContent = '\u26F6'; fsBtn.title = 'Fullscreen';
        }
        fitAll();
    });

    // --- Filtering ---
    const hiddenTypes = new Set();
    function applyErdFilters() {
        erdBoxes.forEach((b, i) => {
            const vis = !hiddenTypes.has(b.objType);
            boxGroups[i].setAttribute('visibility', vis ? 'visible' : 'hidden');
        });
        allLines.forEach(ln => {
            const sVis = !hiddenTypes.has(erdBoxes[ln.fromIdx].objType);
            const tVis = !hiddenTypes.has(erdBoxes[ln.toIdx].objType);
            ln.el.setAttribute('visibility', (sVis && tVis) ? 'visible' : 'hidden');
        });
    }
    window.toggleErdFilter = function(cb) {
        if (cb.checked) hiddenTypes.delete(cb.value); else hiddenTypes.add(cb.value);
        applyErdFilters();
    };
})();
""";
    }

    private static string GetCss() => """
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #1a1a2e; color: #e0e0e0; line-height: 1.6; }
        header { background: #16213e; padding: 2rem; border-bottom: 3px solid #0f3460; }
        h1 { color: #e94560; }
        h2 { color: #0f3460; background: #16213e; padding: 0.8rem 1rem; margin: 1.5rem 0 1rem; border-left: 4px solid #e94560; }
        h3 { color: #e94560; margin: 1rem 0 0.5rem; }
        h4 { color: #4fc3f7; margin: 0.5rem 0 0.3rem; }
        nav { background: #16213e; padding: 0.5rem 1rem; display: flex; gap: 1rem; border-bottom: 1px solid #0f3460; position: sticky; top: 0; z-index: 100; }
        nav a { color: #e94560; text-decoration: none; padding: 0.3rem 0.8rem; border-radius: 4px; }
        nav a:hover { background: #0f3460; }
        main { max-width: 1400px; margin: 0 auto; padding: 1rem 2rem; }
        table { width: 100%; border-collapse: collapse; margin: 0.5rem 0 1rem; background: #16213e; border-radius: 4px; overflow: hidden; }
        th { background: #0f3460; color: #e0e0e0; text-align: left; padding: 0.6rem 0.8rem; font-weight: 600; }
        td { padding: 0.4rem 0.8rem; border-bottom: 1px solid #1a1a2e; }
        tr:hover td { background: #1a1a3e; }
        .meta { color: #888; font-size: 0.9em; }
        .ok { color: #4ecca3; }
        .warn { color: #f0a500; }
        .error { color: #e94560; }
        .info { color: #4fc3f7; }
        .summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem; margin: 1rem 0; }
        .card { background: #16213e; padding: 1.2rem; border-radius: 8px; text-align: center; border: 1px solid #0f3460; }
        .card h3 { color: #4ecca3; font-size: 2em; margin: 0; }
        .card p { color: #888; margin: 0.3rem 0 0; }
        details { margin: 0.5rem 0; }
        summary { cursor: pointer; color: #4fc3f7; padding: 0.3rem 0; }
        footer { text-align: center; padding: 2rem; color: #555; border-top: 1px solid #0f3460; margin-top: 2rem; }
        #graph-container, #erd-container { position: relative; background: #0d0d1a; border: 1px solid #0f3460; border-radius: 8px; margin: 1rem 0; overflow: hidden; }
        #graph-container:fullscreen, #erd-container:fullscreen { background: #0d0d1a; padding: 0; }
        #graph-container:fullscreen #dep-graph, #erd-container:fullscreen #erd-svg { width: 100vw; height: 100vh; }
        #dep-graph, #erd-svg { display: block; }
        .graph-tooltip { display: none; position: absolute; background: #16213e; border: 1px solid #0f3460; padding: 0.6rem 0.8rem; border-radius: 6px; font-size: 0.85em; pointer-events: none; z-index: 10; color: #e0e0e0; box-shadow: 0 4px 12px rgba(0,0,0,0.5); }
        .graph-controls { position: absolute; top: 10px; right: 10px; display: flex; flex-direction: column; gap: 4px; z-index: 10; }
        .graph-controls button { width: 32px; height: 32px; border: 1px solid #0f3460; background: #16213e; color: #e0e0e0; font-size: 18px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .graph-controls button:hover { background: #0f3460; }
        .graph-filters { display: flex; align-items: center; gap: 0.8rem; flex-wrap: wrap; margin: 0.5rem 0; padding: 0.5rem 0.8rem; background: #16213e; border-radius: 6px; border: 1px solid #0f3460; }
        .filter-toggle { display: inline-flex; align-items: center; gap: 0.3rem; cursor: pointer; padding: 0.25rem 0.6rem; border-radius: 4px; border: 1px solid var(--clr); color: var(--clr); font-size: 0.85em; user-select: none; transition: all 0.15s; }
        .filter-toggle:has(input:checked) { background: color-mix(in srgb, var(--clr) 20%, transparent); }
        .filter-toggle:has(input:not(:checked)) { opacity: 0.4; border-style: dashed; }
        .filter-toggle input { display: none; }
        .impact-detail { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; padding: 0.8rem; background: #0d0d1a; border-radius: 6px; margin: 0.5rem 0; }
        .impact-detail ul { list-style: none; padding-left: 0.5rem; }
        .impact-detail li { padding: 0.15rem 0; }
        .impact-detail li::before { content: "→ "; color: #4fc3f7; }
        """;
}
