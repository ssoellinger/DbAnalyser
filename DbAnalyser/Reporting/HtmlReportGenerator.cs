using System.Text;
using System.Text.Json;
using System.Web;
using DbAnalyser.Analyzers;
using DbAnalyser.Models.Quality;
using DbAnalyser.Models.Relationships;

namespace DbAnalyser.Reporting;

public class HtmlReportGenerator : IReportGenerator
{
    public OutputFormat Format => OutputFormat.Html;

    public async Task GenerateAsync(AnalysisResult result, string? outputPath, CancellationToken ct = default)
    {
        var path = outputPath ?? $"DbAnalysis_{result.DatabaseName}_{result.AnalyzedAt:yyyyMMdd_HHmmss}.html";
        var html = BuildHtml(result);
        await File.WriteAllTextAsync(path, html, ct);
        Console.WriteLine($"HTML report written to: {path}");
    }

    private string BuildHtml(AnalysisResult result)
    {
        var sb = new StringBuilder();
        sb.AppendLine("<!DOCTYPE html>");
        sb.AppendLine("<html lang=\"en\">");
        sb.AppendLine("<head>");
        sb.AppendLine("<meta charset=\"UTF-8\">");
        sb.AppendLine("<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">");
        sb.AppendLine($"<title>Database Analysis - {E(result.DatabaseName)}</title>");
        sb.AppendLine("<style>");
        sb.AppendLine(GetCss());
        sb.AppendLine("</style>");
        sb.AppendLine("</head>");
        sb.AppendLine("<body>");
        sb.AppendLine($"<header><h1>Database Analysis: {E(result.DatabaseName)}</h1>");
        sb.AppendLine($"<p class=\"meta\">Analyzed at {result.AnalyzedAt:yyyy-MM-dd HH:mm:ss} UTC</p></header>");

        sb.AppendLine("<nav>");
        if (result.Relationships?.Dependencies.Count > 0) sb.AppendLine("<a href=\"#dependencies\">Dependencies</a>");
        if (result.Schema is not null) sb.AppendLine("<a href=\"#schema\">Schema</a>");
        if (result.Profiles is not null) sb.AppendLine("<a href=\"#profiling\">Profiling</a>");
        if (result.Relationships is not null) sb.AppendLine("<a href=\"#relationships\">Relationships</a>");
        if (result.QualityIssues is not null) sb.AppendLine("<a href=\"#quality\">Quality</a>");
        sb.AppendLine("</nav>");

        sb.AppendLine("<main>");

        if (result.Relationships?.Dependencies.Count > 0)
            BuildDependencySection(sb, result);

        if (result.Schema is not null)
            BuildSchemaSection(sb, result);

        if (result.Profiles is not null)
            BuildProfilingSection(sb, result);

        if (result.Relationships is not null)
            BuildRelationshipsSection(sb, result);

        if (result.QualityIssues is not null)
            BuildQualitySection(sb, result);

        sb.AppendLine("</main>");
        sb.AppendLine("<footer><p>Generated by DbAnalyser</p></footer>");

        if (result.Relationships?.Dependencies.Count > 0)
        {
            sb.AppendLine("<script>");
            sb.AppendLine(GetGraphJs(result));
            sb.AppendLine("</script>");
        }

        sb.AppendLine("</body></html>");

        return sb.ToString();
    }

    private void BuildDependencySection(StringBuilder sb, AnalysisResult result)
    {
        var deps = result.Relationships!.Dependencies;
        var connected = deps.Where(d => d.DirectConnections > 0).ToList();
        var orphaned = deps.Where(d => d.DirectConnections == 0).ToList();

        sb.AppendLine("<section id=\"dependencies\">");
        sb.AppendLine("<h2>Dependency Overview</h2>");

        var tableCount = deps.Count(d => d.ObjectType == "Table");
        var viewCount = deps.Count(d => d.ObjectType == "View");
        var sprocCount = deps.Count(d => d.ObjectType == "Procedure");
        var funcCount = deps.Count(d => d.ObjectType == "Function");
        var triggerCount = deps.Count(d => d.ObjectType == "Trigger");
        var synonymCount = deps.Count(d => d.ObjectType == "Synonym");
        var externalCount = deps.Count(d => d.ObjectType == "External");
        var jobCount = deps.Count(d => d.ObjectType == "Job");
        var crossDbDeps = result.Relationships!.ViewDependencies.Where(d => d.IsCrossDatabase).ToList();

        // Summary cards
        sb.AppendLine("<div class=\"summary-grid\">");
        sb.AppendLine($"<div class=\"card\"><h3>{tableCount}</h3><p>Tables</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{viewCount}</h3><p>Views</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{sprocCount}</h3><p>Procedures</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{funcCount}</h3><p>Functions</p></div>");
        if (triggerCount > 0)
            sb.AppendLine($"<div class=\"card\"><h3>{triggerCount}</h3><p>Triggers</p></div>");
        if (synonymCount > 0)
            sb.AppendLine($"<div class=\"card\"><h3>{synonymCount}</h3><p>Synonyms</p></div>");
        if (jobCount > 0)
            sb.AppendLine($"<div class=\"card\"><h3>{jobCount}</h3><p>Jobs</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{connected.Count}</h3><p>Connected</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{orphaned.Count}</h3><p>Standalone</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{result.Relationships!.ExplicitRelationships.Count}</h3><p>Foreign Keys</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{result.Relationships!.ViewDependencies.Count}</h3><p>Object Dependencies</p></div>");
        if (externalCount > 0)
            sb.AppendLine($"<div class=\"card\"><h3>{externalCount}</h3><p>Cross-DB References</p></div>");
        sb.AppendLine("</div>");

        // Interactive graph
        sb.AppendLine("<h3>Relationship Graph</h3>");
        sb.AppendLine("<p class=\"meta\">Scroll to zoom. Drag empty space to pan. Drag nodes to rearrange. Hover for details. Node size = importance.</p>");

        // Node type filters
        sb.AppendLine("<div class=\"graph-filters\">");
        sb.AppendLine("<span class=\"meta\">Objects:</span>");
        sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#e94560\"><input type=\"checkbox\" value=\"table\" checked onchange=\"toggleNodeFilter(this)\"><span>&#9679; Tables ({tableCount})</span></label>");
        sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#4ecca3\"><input type=\"checkbox\" value=\"view\" checked onchange=\"toggleNodeFilter(this)\"><span>&#9670; Views ({viewCount})</span></label>");
        if (sprocCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#f0a500\"><input type=\"checkbox\" value=\"procedure\" checked onchange=\"toggleNodeFilter(this)\"><span>&#9632; Procedures ({sprocCount})</span></label>");
        if (funcCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#bb86fc\"><input type=\"checkbox\" value=\"function\" checked onchange=\"toggleNodeFilter(this)\"><span>&#9650; Functions ({funcCount})</span></label>");
        if (triggerCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#ff7043\"><input type=\"checkbox\" value=\"trigger\" checked onchange=\"toggleNodeFilter(this)\"><span>&#9889; Triggers ({triggerCount})</span></label>");
        if (synonymCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#78909c\"><input type=\"checkbox\" value=\"synonym\" checked onchange=\"toggleNodeFilter(this)\"><span>&#8801; Synonyms ({synonymCount})</span></label>");
        if (jobCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#26a69a\"><input type=\"checkbox\" value=\"job\" checked onchange=\"toggleNodeFilter(this)\"><span>&#9881; Jobs ({jobCount})</span></label>");
        if (externalCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#ff6b6b\"><input type=\"checkbox\" value=\"external\" checked onchange=\"toggleNodeFilter(this)\"><span>&#9674; External ({externalCount})</span></label>");
        sb.AppendLine("</div>");

        // Edge type filters
        var fkEdgeCount = result.Relationships!.ExplicitRelationships.Count;
        var viewEdgeCount = result.Relationships!.ViewDependencies.Count(d => !d.IsCrossDatabase && d.FromType == "View");
        var sprocEdgeCount = result.Relationships!.ViewDependencies.Count(d => !d.IsCrossDatabase && d.FromType == "Procedure");
        var funcEdgeCount = result.Relationships!.ViewDependencies.Count(d => !d.IsCrossDatabase && d.FromType == "Function");
        var triggerEdgeCount = result.Relationships!.ViewDependencies.Count(d => !d.IsCrossDatabase && d.FromType == "Trigger");
        var synonymEdgeCount = result.Relationships!.ViewDependencies.Count(d => !d.IsCrossDatabase && d.FromType == "Synonym");
        var jobEdgeCount = result.Relationships!.ViewDependencies.Count(d => !d.IsCrossDatabase && d.FromType == "Job");
        var extEdgeCount = result.Relationships!.ViewDependencies.Count(d => d.IsCrossDatabase);

        sb.AppendLine("<div class=\"graph-filters\">");
        sb.AppendLine("<span class=\"meta\">Relations:</span>");
        sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#4fc3f7\"><input type=\"checkbox\" value=\"fk\" checked onchange=\"toggleEdgeFilter(this)\"><span>Table &harr; Table / FK ({fkEdgeCount})</span></label>");
        if (viewEdgeCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#4ecca3\"><input type=\"checkbox\" value=\"view\" checked onchange=\"toggleEdgeFilter(this)\"><span>View &rarr; Object ({viewEdgeCount})</span></label>");
        if (sprocEdgeCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#f0a500\"><input type=\"checkbox\" value=\"procedure\" checked onchange=\"toggleEdgeFilter(this)\"><span>Procedure &rarr; Object ({sprocEdgeCount})</span></label>");
        if (funcEdgeCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#bb86fc\"><input type=\"checkbox\" value=\"function\" checked onchange=\"toggleEdgeFilter(this)\"><span>Function &rarr; Object ({funcEdgeCount})</span></label>");
        if (triggerEdgeCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#ff7043\"><input type=\"checkbox\" value=\"trigger\" checked onchange=\"toggleEdgeFilter(this)\"><span>Trigger &rarr; Object ({triggerEdgeCount})</span></label>");
        if (synonymEdgeCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#78909c\"><input type=\"checkbox\" value=\"synonym\" checked onchange=\"toggleEdgeFilter(this)\"><span>Synonym &rarr; Object ({synonymEdgeCount})</span></label>");
        if (jobEdgeCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#26a69a\"><input type=\"checkbox\" value=\"job\" checked onchange=\"toggleEdgeFilter(this)\"><span>Job &rarr; Object ({jobEdgeCount})</span></label>");
        if (extEdgeCount > 0)
            sb.AppendLine($"<label class=\"filter-toggle\" style=\"--clr:#ff6b6b\"><input type=\"checkbox\" value=\"external\" checked onchange=\"toggleEdgeFilter(this)\"><span>Cross-DB ({extEdgeCount})</span></label>");
        sb.AppendLine("</div>");

        sb.AppendLine("<div id=\"graph-container\"><svg id=\"dep-graph\"></svg></div>");

        // Dependency ranking table
        if (connected.Count > 0)
        {
            sb.AppendLine("<h3>Importance Ranking</h3>");
            sb.AppendLine("<p class=\"meta\">Objects ranked by how central they are. \"Referenced By\" = other objects depend on this one. \"Impact\" = total objects transitively affected.</p>");
            sb.AppendLine("<table><thead><tr><th>Rank</th><th>Object</th><th>Type</th><th>Referenced By</th><th>Depends On</th><th>Transitive Impact</th><th>Score</th></tr></thead><tbody>");

            var rank = 1;
            foreach (var dep in connected.OrderByDescending(d => d.ImportanceScore))
            {
                var impactClass = dep.TransitiveImpact.Count > 10 ? "error" : dep.TransitiveImpact.Count > 5 ? "warn" : "";
                var typeClass = dep.ObjectType switch { "View" => "ok", "Procedure" => "warn", "Function" => "info", "Trigger" => "warn", "Synonym" => "info", "Job" => "ok", "External" => "error", _ => "" };
                sb.AppendLine($"<tr><td>{rank++}</td><td><strong>{E(dep.FullName)}</strong></td><td class=\"{typeClass}\">{dep.ObjectType}</td>");
                sb.AppendLine($"<td>{dep.ReferencedBy.Count}</td>");
                sb.AppendLine($"<td>{dep.DependsOn.Count}</td>");
                sb.AppendLine($"<td class=\"{impactClass}\">{dep.TransitiveImpact.Count}</td>");
                sb.AppendLine($"<td>{dep.ImportanceScore}</td></tr>");
            }
            sb.AppendLine("</tbody></table>");

            // Impact details (expandable per core table)
            var coreTables = connected
                .Where(d => d.ReferencedBy.Count > 0)
                .OrderByDescending(d => d.TransitiveImpact.Count)
                .ToList();

            if (coreTables.Count > 0)
            {
                sb.AppendLine("<h3>Impact Analysis</h3>");
                sb.AppendLine("<p class=\"meta\">If you modify a core table, these tables are affected (directly or transitively).</p>");

                foreach (var dep in coreTables)
                {
                    sb.AppendLine($"<details><summary><strong>{E(dep.FullName)}</strong> â€” {dep.ReferencedBy.Count} direct, {dep.TransitiveImpact.Count} total impact</summary>");
                    sb.AppendLine("<div class=\"impact-detail\">");

                    sb.AppendLine("<div class=\"impact-col\"><h4>Direct dependents</h4><ul>");
                    foreach (var t in dep.ReferencedBy.Order())
                        sb.AppendLine($"<li>{E(t)}</li>");
                    sb.AppendLine("</ul></div>");

                    if (dep.TransitiveImpact.Count > dep.ReferencedBy.Count)
                    {
                        var indirect = dep.TransitiveImpact.Except(dep.ReferencedBy, StringComparer.OrdinalIgnoreCase).Order();
                        sb.AppendLine("<div class=\"impact-col\"><h4>Indirect (transitive)</h4><ul>");
                        foreach (var t in indirect)
                            sb.AppendLine($"<li class=\"meta\">{E(t)}</li>");
                        sb.AppendLine("</ul></div>");
                    }

                    sb.AppendLine("<div class=\"impact-col\"><h4>This table depends on</h4><ul>");
                    foreach (var t in dep.DependsOn.Order())
                        sb.AppendLine($"<li>{E(t)}</li>");
                    if (dep.DependsOn.Count == 0)
                        sb.AppendLine("<li class=\"meta\">None (root table)</li>");
                    sb.AppendLine("</ul></div>");

                    sb.AppendLine("</div></details>");
                }
            }
        }

        // Orphaned tables
        if (orphaned.Count > 0)
        {
            sb.AppendLine("<details><summary><h3 style=\"display:inline\">Standalone Tables</h3> <span class=\"meta\">(" + orphaned.Count + " tables with no FK relationships)</span></summary><ul>");
            foreach (var dep in orphaned.OrderBy(d => d.FullName))
                sb.AppendLine($"<li>{E(dep.FullName)}</li>");
            sb.AppendLine("</ul></details>");
        }

        sb.AppendLine("</section>");
    }

    private void BuildSchemaSection(StringBuilder sb, AnalysisResult result)
    {
        var schema = result.Schema!;
        sb.AppendLine("<section id=\"schema\">");
        sb.AppendLine("<h2>Schema Overview</h2>");

        sb.AppendLine("<div class=\"summary-grid\">");
        sb.AppendLine($"<div class=\"card\"><h3>{schema.Tables.Count}</h3><p>Tables</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{schema.Views.Count}</h3><p>Views</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{schema.StoredProcedures.Count}</h3><p>Stored Procedures</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{schema.Functions.Count}</h3><p>Functions</p></div>");
        if (schema.Triggers.Count > 0)
            sb.AppendLine($"<div class=\"card\"><h3>{schema.Triggers.Count}</h3><p>Triggers</p></div>");
        if (schema.Synonyms.Count > 0)
            sb.AppendLine($"<div class=\"card\"><h3>{schema.Synonyms.Count}</h3><p>Synonyms</p></div>");
        if (schema.Sequences.Count > 0)
            sb.AppendLine($"<div class=\"card\"><h3>{schema.Sequences.Count}</h3><p>Sequences</p></div>");
        if (schema.UserDefinedTypes.Count > 0)
            sb.AppendLine($"<div class=\"card\"><h3>{schema.UserDefinedTypes.Count}</h3><p>User-Defined Types</p></div>");
        if (schema.Jobs.Count > 0)
            sb.AppendLine($"<div class=\"card\"><h3>{schema.Jobs.Count}</h3><p>SQL Agent Jobs</p></div>");
        sb.AppendLine($"<div class=\"card\"><h3>{schema.Tables.Sum(t => t.Columns.Count)}</h3><p>Total Columns</p></div>");
        sb.AppendLine("</div>");

        foreach (var table in schema.Tables)
        {
            sb.AppendLine($"<h3 id=\"table-{E(table.FullName)}\">{E(table.FullName)}</h3>");
            sb.AppendLine("<table><thead><tr><th>Column</th><th>Type</th><th>Nullable</th><th>PK</th><th>Identity</th><th>Default</th></tr></thead><tbody>");

            foreach (var col in table.Columns)
            {
                var typeStr = col.MaxLength.HasValue
                    ? $"{col.DataType}({(col.MaxLength == -1 ? "MAX" : col.MaxLength.ToString())})"
                    : col.Precision.HasValue
                        ? $"{col.DataType}({col.Precision},{col.Scale})"
                        : col.DataType;

                sb.AppendLine($"<tr><td>{E(col.Name)}</td><td>{typeStr}</td>");
                sb.AppendLine($"<td>{(col.IsNullable ? "<span class=\"warn\">YES</span>" : "NO")}</td>");
                sb.AppendLine($"<td>{(col.IsPrimaryKey ? "<span class=\"ok\">PK</span>" : "")}</td>");
                sb.AppendLine($"<td>{(col.IsIdentity ? "Yes" : "")}</td>");
                sb.AppendLine($"<td>{E(col.DefaultValue ?? "")}</td></tr>");
            }

            sb.AppendLine("</tbody></table>");

            if (table.Indexes.Count > 0)
            {
                sb.AppendLine("<details><summary>Indexes</summary>");
                sb.AppendLine("<table><thead><tr><th>Name</th><th>Type</th><th>Unique</th><th>Columns</th></tr></thead><tbody>");
                foreach (var idx in table.Indexes)
                {
                    sb.AppendLine($"<tr><td>{E(idx.Name)}</td><td>{idx.Type}</td><td>{(idx.IsUnique ? "Yes" : "No")}</td><td>{E(string.Join(", ", idx.Columns))}</td></tr>");
                }
                sb.AppendLine("</tbody></table></details>");
            }
        }

        // Triggers
        if (schema.Triggers.Count > 0)
        {
            sb.AppendLine("<h3>Triggers</h3>");
            sb.AppendLine("<table><thead><tr><th>Trigger</th><th>Parent Table</th><th>Type</th><th>Events</th><th>Enabled</th></tr></thead><tbody>");
            foreach (var tr in schema.Triggers)
            {
                var enabledLabel = tr.IsEnabled ? "<span class=\"ok\">Yes</span>" : "<span class=\"error\">No</span>";
                sb.AppendLine($"<tr><td>{E(tr.FullName)}</td><td>{E(tr.ParentFullName)}</td><td>{tr.TriggerType}</td><td>{E(tr.TriggerEvents)}</td><td>{enabledLabel}</td></tr>");
            }
            sb.AppendLine("</tbody></table>");
        }

        // Synonyms
        if (schema.Synonyms.Count > 0)
        {
            sb.AppendLine("<h3>Synonyms</h3>");
            sb.AppendLine("<table><thead><tr><th>Synonym</th><th>Base Object</th></tr></thead><tbody>");
            foreach (var syn in schema.Synonyms)
            {
                sb.AppendLine($"<tr><td>{E(syn.FullName)}</td><td>{E(syn.BaseObjectName)}</td></tr>");
            }
            sb.AppendLine("</tbody></table>");
        }

        // Sequences
        if (schema.Sequences.Count > 0)
        {
            sb.AppendLine("<h3>Sequences</h3>");
            sb.AppendLine("<table><thead><tr><th>Sequence</th><th>Data Type</th><th>Current</th><th>Increment</th><th>Min</th><th>Max</th><th>Cycling</th></tr></thead><tbody>");
            foreach (var seq in schema.Sequences)
            {
                sb.AppendLine($"<tr><td>{E(seq.FullName)}</td><td>{seq.DataType}</td><td>{seq.CurrentValue:N0}</td><td>{seq.Increment}</td><td>{seq.MinValue:N0}</td><td>{seq.MaxValue:N0}</td><td>{(seq.IsCycling ? "Yes" : "No")}</td></tr>");
            }
            sb.AppendLine("</tbody></table>");
        }

        // User-Defined Types
        if (schema.UserDefinedTypes.Count > 0)
        {
            sb.AppendLine("<h3>User-Defined Types</h3>");
            sb.AppendLine("<table><thead><tr><th>Type</th><th>Base Type</th><th>Table Type</th><th>Nullable</th><th>Max Length</th></tr></thead><tbody>");
            foreach (var udt in schema.UserDefinedTypes)
            {
                sb.AppendLine($"<tr><td>{E(udt.FullName)}</td><td>{udt.BaseType}</td><td>{(udt.IsTableType ? "Yes" : "No")}</td><td>{(udt.IsNullable ? "Yes" : "No")}</td><td>{(udt.MaxLength.HasValue ? udt.MaxLength.ToString() : "N/A")}</td></tr>");
            }
            sb.AppendLine("</tbody></table>");
        }

        sb.AppendLine("</section>");
    }

    private void BuildProfilingSection(StringBuilder sb, AnalysisResult result)
    {
        sb.AppendLine("<section id=\"profiling\">");
        sb.AppendLine("<h2>Data Profiling</h2>");

        foreach (var profile in result.Profiles!)
        {
            sb.AppendLine($"<h3>{E(profile.FullName)} <span class=\"meta\">({profile.RowCount:N0} rows)</span></h3>");

            if (profile.RowCount == 0)
            {
                sb.AppendLine("<p class=\"meta\">Empty table</p>");
                continue;
            }

            sb.AppendLine("<table><thead><tr><th>Column</th><th>Type</th><th>Null %</th><th>Distinct</th><th>Min</th><th>Max</th></tr></thead><tbody>");

            foreach (var col in profile.ColumnProfiles)
            {
                var nullClass = col.NullPercentage > 50 ? "error" : col.NullPercentage > 0 ? "warn" : "ok";
                sb.AppendLine($"<tr><td>{E(col.ColumnName)}</td><td>{col.DataType}</td>");
                sb.AppendLine($"<td class=\"{nullClass}\">{col.NullPercentage:F1}%</td>");
                sb.AppendLine($"<td>{col.DistinctCount:N0}</td>");
                sb.AppendLine($"<td>{E(Truncate(col.MinValue, 40))}</td>");
                sb.AppendLine($"<td>{E(Truncate(col.MaxValue, 40))}</td></tr>");
            }

            sb.AppendLine("</tbody></table>");
        }

        sb.AppendLine("</section>");
    }

    private void BuildRelationshipsSection(StringBuilder sb, AnalysisResult result)
    {
        var map = result.Relationships!;
        sb.AppendLine("<section id=\"relationships\">");
        sb.AppendLine("<h2>Relationships Detail</h2>");

        if (map.ExplicitRelationships.Count > 0)
        {
            sb.AppendLine("<h3>Explicit Foreign Keys</h3>");
            sb.AppendLine("<table><thead><tr><th>Name</th><th>From</th><th>To</th><th>Delete</th><th>Update</th></tr></thead><tbody>");
            foreach (var fk in map.ExplicitRelationships)
            {
                sb.AppendLine($"<tr><td>{E(fk.Name)}</td>");
                sb.AppendLine($"<td>{E(fk.FromSchema)}.{E(fk.FromTable)}.{E(fk.FromColumn)}</td>");
                sb.AppendLine($"<td>{E(fk.ToSchema)}.{E(fk.ToTable)}.{E(fk.ToColumn)}</td>");
                sb.AppendLine($"<td>{fk.DeleteRule}</td><td>{fk.UpdateRule}</td></tr>");
            }
            sb.AppendLine("</tbody></table>");
        }

        if (map.ViewDependencies.Count > 0)
        {
            sb.AppendLine("<h3>Object Dependencies (Views, Procedures, Functions)</h3>");
            sb.AppendLine("<table><thead><tr><th>Object</th><th>Type</th><th>Depends On</th><th>Target Type</th><th>Database</th></tr></thead><tbody>");
            foreach (var vd in map.ViewDependencies)
            {
                var dbLabel = vd.IsCrossDatabase ? $"<span class=\"error\">{E(vd.ToDatabase!)}</span>" : "<span class=\"meta\">local</span>";
                sb.AppendLine($"<tr><td>{E(vd.FromSchema)}.{E(vd.FromName)}</td><td>{vd.FromType}</td>");
                sb.AppendLine($"<td>{E(vd.ToFullName)}</td><td>{vd.ToType}</td><td>{dbLabel}</td></tr>");
            }
            sb.AppendLine("</tbody></table>");
        }

        if (map.ImplicitRelationships.Count > 0)
        {
            sb.AppendLine("<h3>Implicit (Detected) Relationships</h3>");
            sb.AppendLine("<table><thead><tr><th>From</th><th>To</th><th>Confidence</th><th>Reason</th></tr></thead><tbody>");
            foreach (var rel in map.ImplicitRelationships)
            {
                sb.AppendLine($"<tr><td>{E(rel.FromSchema)}.{E(rel.FromTable)}.{E(rel.FromColumn)}</td>");
                sb.AppendLine($"<td>{E(rel.ToSchema)}.{E(rel.ToTable)}.{E(rel.ToColumn)}</td>");
                sb.AppendLine($"<td>{rel.Confidence:P0}</td><td>{E(rel.Reason)}</td></tr>");
            }
            sb.AppendLine("</tbody></table>");
        }

        sb.AppendLine("</section>");
    }

    private void BuildQualitySection(StringBuilder sb, AnalysisResult result)
    {
        var issues = result.QualityIssues!;
        sb.AppendLine("<section id=\"quality\">");
        sb.AppendLine("<h2>Quality Issues</h2>");

        if (issues.Count == 0)
        {
            sb.AppendLine("<p class=\"ok\">No quality issues found.</p>");
            sb.AppendLine("</section>");
            return;
        }

        var grouped = issues.GroupBy(i => i.Severity).OrderByDescending(g => g.Key);
        foreach (var group in grouped)
        {
            var cssClass = group.Key switch
            {
                IssueSeverity.Error => "error",
                IssueSeverity.Warning => "warn",
                _ => "info"
            };

            sb.AppendLine($"<h3 class=\"{cssClass}\">{group.Key} ({group.Count()})</h3>");
            sb.AppendLine("<table><thead><tr><th>Object</th><th>Category</th><th>Issue</th><th>Recommendation</th></tr></thead><tbody>");
            foreach (var issue in group)
            {
                sb.AppendLine($"<tr><td>{E(issue.ObjectName)}</td><td>{issue.Category}</td>");
                sb.AppendLine($"<td>{E(issue.Description)}</td><td>{E(issue.Recommendation ?? "")}</td></tr>");
            }
            sb.AppendLine("</tbody></table>");
        }

        sb.AppendLine("</section>");
    }

    private static string E(string text) => HttpUtility.HtmlEncode(text);

    private static string Truncate(string? value, int maxLength)
    {
        if (string.IsNullOrEmpty(value)) return "";
        return value.Length <= maxLength ? value : value[..maxLength] + "...";
    }

    private string GetGraphJs(AnalysisResult result)
    {
        var deps = result.Relationships!.Dependencies;
        var fks = result.Relationships!.ExplicitRelationships;
        var viewDeps = result.Relationships!.ViewDependencies;

        // Build nodes array
        var connected = deps.Where(d => d.DirectConnections > 0).ToList();
        var nodeIndex = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
        var nodes = new List<object>();
        for (var i = 0; i < connected.Count; i++)
        {
            var d = connected[i];
            nodeIndex[d.FullName] = i;
            nodes.Add(new
            {
                id = d.FullName,
                label = d.IsExternal ? d.FullName : $"{d.SchemaName}.{d.TableName}",
                type = d.ObjectType.ToLowerInvariant(),
                refBy = d.ReferencedBy.Count,
                depOn = d.DependsOn.Count,
                impact = d.TransitiveImpact.Count,
                score = d.ImportanceScore
            });
        }

        // Build edges (deduplicated at object level)
        var edgeSet = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        var edges = new List<object>();
        foreach (var fk in fks)
        {
            var from = $"{fk.FromSchema}.{fk.FromTable}";
            var to = $"{fk.ToSchema}.{fk.ToTable}";
            var key = $"{from}->{to}";
            if (!edgeSet.Add(key)) continue;
            if (!nodeIndex.ContainsKey(from) || !nodeIndex.ContainsKey(to)) continue;
            edges.Add(new { source = nodeIndex[from], target = nodeIndex[to], type = "fk" });
        }

        // Add object dependency edges (views, procedures, functions, cross-DB)
        foreach (var vd in viewDeps)
        {
            var from = $"{vd.FromSchema}.{vd.FromName}";
            var to = vd.ToFullName;
            var key = $"{from}->{to}";
            if (!edgeSet.Add(key)) continue;
            if (!nodeIndex.ContainsKey(from) || !nodeIndex.ContainsKey(to)) continue;
            var edgeType = vd.IsCrossDatabase ? "external" : vd.FromType.ToLowerInvariant();
            edges.Add(new { source = nodeIndex[from], target = nodeIndex[to], type = edgeType });
        }

        var nodesJson = JsonSerializer.Serialize(nodes);
        var edgesJson = JsonSerializer.Serialize(edges);

        return $$"""
const graphNodes = {{nodesJson}};
const graphEdges = {{edgesJson}};

(function() {
    const svg = document.getElementById('dep-graph');
    const container = document.getElementById('graph-container');
    const width = container.clientWidth || 1200;
    const height = Math.max(600, Math.min(graphNodes.length * 12, 1000));
    svg.setAttribute('width', width);
    svg.setAttribute('height', height);

    // Zoom/pan state
    let vb = { x: 0, y: 0, w: width, h: height };
    const updateViewBox = () => svg.setAttribute('viewBox', `${vb.x} ${vb.y} ${vb.w} ${vb.h}`);
    updateViewBox();

    // Convert screen coords to world (SVG) coords
    function screenToWorld(sx, sy) {
        const rect = svg.getBoundingClientRect();
        return {
            x: vb.x + (sx - rect.left) / rect.width * vb.w,
            y: vb.y + (sy - rect.top) / rect.height * vb.h
        };
    }

    const maxScore = Math.max(...graphNodes.map(n => n.score), 1);

    // Initialize positions in a circle
    graphNodes.forEach((n, i) => {
        const angle = (2 * Math.PI * i) / graphNodes.length;
        const r = Math.min(width, height) * 0.35;
        n.x = width / 2 + r * Math.cos(angle);
        n.y = height / 2 + r * Math.sin(angle);
        n.vx = 0;
        n.vy = 0;
        n.radius = 6 + (n.score / maxScore) * 20;
    });

    // SVG defs
    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
    marker.setAttribute('id', 'arrow');
    marker.setAttribute('viewBox', '0 0 10 10');
    marker.setAttribute('refX', '10');
    marker.setAttribute('refY', '5');
    marker.setAttribute('markerWidth', '6');
    marker.setAttribute('markerHeight', '6');
    marker.setAttribute('orient', 'auto-start-reverse');
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
    path.setAttribute('fill', '#4fc3f7');
    marker.appendChild(path);
    defs.appendChild(marker);
    svg.appendChild(defs);

    const edgeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const nodeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const labelGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    svg.appendChild(edgeGroup);
    svg.appendChild(nodeGroup);
    svg.appendChild(labelGroup);

    // Tooltip
    const tooltip = document.createElement('div');
    tooltip.className = 'graph-tooltip';
    container.appendChild(tooltip);

    // Zoom controls
    const controls = document.createElement('div');
    controls.className = 'graph-controls';
    controls.innerHTML = '<button id="zoom-in" title="Zoom in">+</button><button id="zoom-out" title="Zoom out">&minus;</button><button id="zoom-fit" title="Fit all">&#8634;</button>';
    container.appendChild(controls);

    // Create edge elements
    const edgeColors = { fk: '#4fc3f7', view: '#4ecca3', procedure: '#f0a500', function: '#bb86fc', trigger: '#ff7043', synonym: '#78909c', job: '#26a69a', external: '#ff6b6b' };
    const edgeEls = graphEdges.map(e => {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        const color = edgeColors[e.type] || '#4fc3f7';
        line.setAttribute('stroke', color);
        line.setAttribute('stroke-opacity', '0.4');
        line.setAttribute('stroke-width', '1.5');
        if (e.type !== 'fk') line.setAttribute('stroke-dasharray', '6,3');
        line.setAttribute('marker-end', 'url(#arrow)');
        edgeGroup.appendChild(line);
        return line;
    });

    // Create node elements
    const nodeEls = graphNodes.map((n, i) => {
        if (n.type === 'view') {
            const diamond = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            diamond.setAttribute('fill', '#4ecca3');
            diamond.setAttribute('stroke', '#e0e0e0');
            diamond.setAttribute('stroke-width', '1');
            diamond.setAttribute('cursor', 'grab');
            nodeGroup.appendChild(diamond);
            return diamond;
        }
        if (n.type === 'procedure') {
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('fill', '#f0a500');
            rect.setAttribute('stroke', '#e0e0e0');
            rect.setAttribute('stroke-width', '1');
            rect.setAttribute('cursor', 'grab');
            nodeGroup.appendChild(rect);
            return rect;
        }
        if (n.type === 'function') {
            const tri = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            tri.setAttribute('fill', '#bb86fc');
            tri.setAttribute('stroke', '#e0e0e0');
            tri.setAttribute('stroke-width', '1');
            tri.setAttribute('cursor', 'grab');
            nodeGroup.appendChild(tri);
            return tri;
        }
        if (n.type === 'trigger') {
            // Star/bolt shape (rotated diamond with notch)
            const star = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            star.setAttribute('fill', '#ff7043');
            star.setAttribute('stroke', '#e0e0e0');
            star.setAttribute('stroke-width', '1');
            star.setAttribute('cursor', 'grab');
            nodeGroup.appendChild(star);
            return star;
        }
        if (n.type === 'synonym') {
            // Rounded rect (pill shape)
            const pill = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            pill.setAttribute('fill', '#78909c');
            pill.setAttribute('stroke', '#e0e0e0');
            pill.setAttribute('stroke-width', '1');
            pill.setAttribute('cursor', 'grab');
            nodeGroup.appendChild(pill);
            return pill;
        }
        if (n.type === 'job') {
            const hex = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            hex.setAttribute('fill', '#26a69a');
            hex.setAttribute('stroke', '#e0e0e0');
            hex.setAttribute('stroke-width', '1');
            hex.setAttribute('cursor', 'grab');
            nodeGroup.appendChild(hex);
            return hex;
        }
        if (n.type === 'external') {
            const diamond = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            diamond.setAttribute('fill', 'none');
            diamond.setAttribute('stroke', '#ff6b6b');
            diamond.setAttribute('stroke-width', '2');
            diamond.setAttribute('stroke-dasharray', '4,2');
            diamond.setAttribute('cursor', 'grab');
            nodeGroup.appendChild(diamond);
            return diamond;
        }
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('r', n.radius);
        const hue = n.refBy > 0 ? (n.refBy > 5 ? 0 : 30) : 200;
        circle.setAttribute('fill', `hsl(${hue}, 70%, ${50 + (n.score / maxScore) * 20}%)`);
        circle.setAttribute('stroke', '#e0e0e0');
        circle.setAttribute('stroke-width', '1');
        circle.setAttribute('cursor', 'grab');
        nodeGroup.appendChild(circle);
        return circle;
    });

    // Hover/tooltip
    nodeEls.forEach((el, i) => {
        const n = graphNodes[i];
        el.addEventListener('mouseenter', (ev) => {
            tooltip.innerHTML = `<strong>${n.id}</strong><br>Type: ${n.type}<br>Referenced by: ${n.refBy}<br>Depends on: ${n.depOn}<br>Impact: ${n.impact}<br>Score: ${n.score}`;
            tooltip.style.display = 'block';
            const cr = container.getBoundingClientRect();
            tooltip.style.left = (ev.clientX - cr.left + 15) + 'px';
            tooltip.style.top = (ev.clientY - cr.top - 10) + 'px';
            graphEdges.forEach((e, ei) => {
                if (e.source === i || e.target === i) {
                    edgeEls[ei].setAttribute('stroke-opacity', '1');
                    edgeEls[ei].setAttribute('stroke-width', '2.5');
                }
            });
            el.setAttribute('stroke-width', '3');
        });
        el.addEventListener('mouseleave', () => {
            tooltip.style.display = 'none';
            graphEdges.forEach((e, ei) => {
                edgeEls[ei].setAttribute('stroke-opacity', '0.4');
                edgeEls[ei].setAttribute('stroke-width', '1.5');
            });
            el.setAttribute('stroke-width', '1');
        });
    });

    // Labels
    const labelEls = graphNodes.map(n => {
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.textContent = n.label;
        text.setAttribute('font-size', Math.max(9, Math.min(13, 8 + n.radius / 4)));
        text.setAttribute('fill', '#e0e0e0');
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('pointer-events', 'none');
        labelGroup.appendChild(text);
        return text;
    });

    // --- Zoom ---
    function zoomBy(factor, cx, cy) {
        const newW = vb.w / factor, newH = vb.h / factor;
        vb.x = cx - (cx - vb.x) / factor;
        vb.y = cy - (cy - vb.y) / factor;
        vb.w = newW;
        vb.h = newH;
        updateViewBox();
    }

    svg.addEventListener('wheel', (ev) => {
        ev.preventDefault();
        const p = screenToWorld(ev.clientX, ev.clientY);
        const factor = ev.deltaY < 0 ? 1.15 : 1 / 1.15;
        zoomBy(factor, p.x, p.y);
    }, { passive: false });

    document.getElementById('zoom-in').addEventListener('click', () => {
        const cx = vb.x + vb.w / 2, cy = vb.y + vb.h / 2;
        zoomBy(1.3, cx, cy);
    });
    document.getElementById('zoom-out').addEventListener('click', () => {
        const cx = vb.x + vb.w / 2, cy = vb.y + vb.h / 2;
        zoomBy(1 / 1.3, cx, cy);
    });
    document.getElementById('zoom-fit').addEventListener('click', () => {
        vb = { x: 0, y: 0, w: width, h: height };
        updateViewBox();
    });

    // --- Drag nodes + Pan ---
    let dragNode = null, dragOffset = {x:0,y:0};
    let isPanning = false, panStart = {x:0,y:0}, vbStart = {x:0,y:0};

    svg.addEventListener('mousedown', (ev) => {
        const p = screenToWorld(ev.clientX, ev.clientY);
        // Check if clicking a node
        for (let i = 0; i < graphNodes.length; i++) {
            const n = graphNodes[i];
            if (Math.hypot(p.x - n.x, p.y - n.y) < n.radius + 5) {
                dragNode = i;
                dragOffset = { x: p.x - n.x, y: p.y - n.y };
                graphNodes[i].fx = n.x;
                graphNodes[i].fy = n.y;
                svg.style.cursor = 'grabbing';
                return;
            }
        }
        // Otherwise start panning
        isPanning = true;
        panStart = { x: ev.clientX, y: ev.clientY };
        vbStart = { x: vb.x, y: vb.y };
        svg.style.cursor = 'move';
    });

    svg.addEventListener('mousemove', (ev) => {
        if (dragNode !== null) {
            const p = screenToWorld(ev.clientX, ev.clientY);
            graphNodes[dragNode].fx = p.x - dragOffset.x;
            graphNodes[dragNode].fy = p.y - dragOffset.y;
        } else if (isPanning) {
            const rect = svg.getBoundingClientRect();
            const dx = (ev.clientX - panStart.x) / rect.width * vb.w;
            const dy = (ev.clientY - panStart.y) / rect.height * vb.h;
            vb.x = vbStart.x - dx;
            vb.y = vbStart.y - dy;
            updateViewBox();
        }
    });

    svg.addEventListener('mouseup', () => {
        if (dragNode !== null) {
            graphNodes[dragNode].x = graphNodes[dragNode].fx;
            graphNodes[dragNode].y = graphNodes[dragNode].fy;
            delete graphNodes[dragNode].fx;
            delete graphNodes[dragNode].fy;
        }
        dragNode = null;
        isPanning = false;
        svg.style.cursor = 'default';
    });

    svg.addEventListener('mouseleave', () => {
        isPanning = false;
        if (dragNode !== null) {
            graphNodes[dragNode].x = graphNodes[dragNode].fx;
            graphNodes[dragNode].y = graphNodes[dragNode].fy;
            delete graphNodes[dragNode].fx;
            delete graphNodes[dragNode].fy;
            dragNode = null;
        }
        svg.style.cursor = 'default';
    });

    // Force simulation
    function tick() {
        const N = graphNodes.length;
        for (let i = 0; i < N; i++) {
            for (let j = i + 1; j < N; j++) {
                let dx = graphNodes[i].x - graphNodes[j].x;
                let dy = graphNodes[i].y - graphNodes[j].y;
                let dist = Math.sqrt(dx*dx + dy*dy) || 1;
                let force = 800 / (dist * dist);
                let fx = dx / dist * force;
                let fy = dy / dist * force;
                graphNodes[i].vx += fx;
                graphNodes[i].vy += fy;
                graphNodes[j].vx -= fx;
                graphNodes[j].vy -= fy;
            }
        }
        graphEdges.forEach(e => {
            let s = graphNodes[e.source], t = graphNodes[e.target];
            let dx = t.x - s.x, dy = t.y - s.y;
            let dist = Math.sqrt(dx*dx + dy*dy) || 1;
            let force = (dist - 120) * 0.005;
            let fx = dx / dist * force;
            let fy = dy / dist * force;
            s.vx += fx; s.vy += fy;
            t.vx -= fx; t.vy -= fy;
        });
        graphNodes.forEach(n => {
            n.vx += (width/2 - n.x) * 0.001;
            n.vy += (height/2 - n.y) * 0.001;
        });
        graphNodes.forEach((n, i) => {
            if (i === dragNode) {
                n.x = n.fx; n.y = n.fy;
                n.vx = 0; n.vy = 0;
                return;
            }
            n.vx *= 0.85;
            n.vy *= 0.85;
            n.x += n.vx;
            n.y += n.vy;
        });
        // Update SVG
        graphEdges.forEach((e, i) => {
            let s = graphNodes[e.source], t = graphNodes[e.target];
            let dx = t.x - s.x, dy = t.y - s.y;
            let dist = Math.sqrt(dx*dx + dy*dy) || 1;
            let offsetS = s.radius / dist, offsetT = t.radius / dist;
            edgeEls[i].setAttribute('x1', s.x + dx * offsetS);
            edgeEls[i].setAttribute('y1', s.y + dy * offsetS);
            edgeEls[i].setAttribute('x2', t.x - dx * offsetT);
            edgeEls[i].setAttribute('y2', t.y - dy * offsetT);
        });
        nodeEls.forEach((el, i) => {
            const n = graphNodes[i];
            if (n.type === 'view') {
                const r = n.radius;
                el.setAttribute('points', `${n.x},${n.y-r} ${n.x+r},${n.y} ${n.x},${n.y+r} ${n.x-r},${n.y}`);
            } else if (n.type === 'procedure') {
                const r = n.radius;
                el.setAttribute('x', n.x - r);
                el.setAttribute('y', n.y - r);
                el.setAttribute('width', r * 2);
                el.setAttribute('height', r * 2);
                el.setAttribute('rx', '3');
            } else if (n.type === 'function') {
                const r = n.radius;
                el.setAttribute('points', `${n.x},${n.y-r} ${n.x+r},${n.y+r} ${n.x-r},${n.y+r}`);
            } else if (n.type === 'trigger') {
                const r = n.radius;
                // 5-point star
                let pts = '';
                for (let k = 0; k < 5; k++) {
                    const outerAngle = (Math.PI * 2 * k / 5) - Math.PI / 2;
                    const innerAngle = outerAngle + Math.PI / 5;
                    pts += `${n.x + r * Math.cos(outerAngle)},${n.y + r * Math.sin(outerAngle)} `;
                    pts += `${n.x + r * 0.45 * Math.cos(innerAngle)},${n.y + r * 0.45 * Math.sin(innerAngle)} `;
                }
                el.setAttribute('points', pts.trim());
            } else if (n.type === 'synonym') {
                const r = n.radius;
                el.setAttribute('x', n.x - r * 1.3);
                el.setAttribute('y', n.y - r * 0.7);
                el.setAttribute('width', r * 2.6);
                el.setAttribute('height', r * 1.4);
                el.setAttribute('rx', r * 0.7);
            } else if (n.type === 'job') {
                const r = n.radius;
                const a = Math.PI / 3;
                let pts = '';
                for (let k = 0; k < 6; k++) {
                    const angle = a * k - Math.PI / 6;
                    pts += `${n.x + r * Math.cos(angle)},${n.y + r * Math.sin(angle)} `;
                }
                el.setAttribute('points', pts.trim());
            } else if (n.type === 'external') {
                const r = n.radius;
                el.setAttribute('points', `${n.x},${n.y-r} ${n.x+r},${n.y} ${n.x},${n.y+r} ${n.x-r},${n.y}`);
            } else {
                el.setAttribute('cx', n.x);
                el.setAttribute('cy', n.y);
            }
        });
        labelEls.forEach((el, i) => {
            el.setAttribute('x', graphNodes[i].x);
            el.setAttribute('y', graphNodes[i].y + graphNodes[i].radius + 14);
        });
        requestAnimationFrame(tick);
    }
    tick();

    // --- Filtering ---
    const hiddenNodeTypes = new Set();
    const hiddenEdgeTypes = new Set();

    function applyFilters() {
        graphNodes.forEach((n, i) => {
            const vis = !hiddenNodeTypes.has(n.type);
            nodeEls[i].setAttribute('visibility', vis ? 'visible' : 'hidden');
            labelEls[i].setAttribute('visibility', vis ? 'visible' : 'hidden');
        });
        graphEdges.forEach((e, i) => {
            const sVis = !hiddenNodeTypes.has(graphNodes[e.source].type);
            const tVis = !hiddenNodeTypes.has(graphNodes[e.target].type);
            const edgeVis = !hiddenEdgeTypes.has(e.type);
            edgeEls[i].setAttribute('visibility', (sVis && tVis && edgeVis) ? 'visible' : 'hidden');
        });
    }

    window.toggleNodeFilter = function(cb) {
        if (cb.checked) hiddenNodeTypes.delete(cb.value);
        else hiddenNodeTypes.add(cb.value);
        applyFilters();
    };

    window.toggleEdgeFilter = function(cb) {
        if (cb.checked) hiddenEdgeTypes.delete(cb.value);
        else hiddenEdgeTypes.add(cb.value);
        applyFilters();
    };
})();
""";
    }

    private static string GetCss() => """
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #1a1a2e; color: #e0e0e0; line-height: 1.6; }
        header { background: #16213e; padding: 2rem; border-bottom: 3px solid #0f3460; }
        h1 { color: #e94560; }
        h2 { color: #0f3460; background: #16213e; padding: 0.8rem 1rem; margin: 1.5rem 0 1rem; border-left: 4px solid #e94560; }
        h3 { color: #e94560; margin: 1rem 0 0.5rem; }
        h4 { color: #4fc3f7; margin: 0.5rem 0 0.3rem; }
        nav { background: #16213e; padding: 0.5rem 1rem; display: flex; gap: 1rem; border-bottom: 1px solid #0f3460; position: sticky; top: 0; z-index: 100; }
        nav a { color: #e94560; text-decoration: none; padding: 0.3rem 0.8rem; border-radius: 4px; }
        nav a:hover { background: #0f3460; }
        main { max-width: 1400px; margin: 0 auto; padding: 1rem 2rem; }
        table { width: 100%; border-collapse: collapse; margin: 0.5rem 0 1rem; background: #16213e; border-radius: 4px; overflow: hidden; }
        th { background: #0f3460; color: #e0e0e0; text-align: left; padding: 0.6rem 0.8rem; font-weight: 600; }
        td { padding: 0.4rem 0.8rem; border-bottom: 1px solid #1a1a2e; }
        tr:hover td { background: #1a1a3e; }
        .meta { color: #888; font-size: 0.9em; }
        .ok { color: #4ecca3; }
        .warn { color: #f0a500; }
        .error { color: #e94560; }
        .info { color: #4fc3f7; }
        .summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem; margin: 1rem 0; }
        .card { background: #16213e; padding: 1.2rem; border-radius: 8px; text-align: center; border: 1px solid #0f3460; }
        .card h3 { color: #4ecca3; font-size: 2em; margin: 0; }
        .card p { color: #888; margin: 0.3rem 0 0; }
        details { margin: 0.5rem 0; }
        summary { cursor: pointer; color: #4fc3f7; padding: 0.3rem 0; }
        footer { text-align: center; padding: 2rem; color: #555; border-top: 1px solid #0f3460; margin-top: 2rem; }
        #graph-container { position: relative; background: #0d0d1a; border: 1px solid #0f3460; border-radius: 8px; margin: 1rem 0; overflow: hidden; }
        #dep-graph { display: block; }
        .graph-tooltip { display: none; position: absolute; background: #16213e; border: 1px solid #0f3460; padding: 0.6rem 0.8rem; border-radius: 6px; font-size: 0.85em; pointer-events: none; z-index: 10; color: #e0e0e0; box-shadow: 0 4px 12px rgba(0,0,0,0.5); }
        .graph-controls { position: absolute; top: 10px; right: 10px; display: flex; flex-direction: column; gap: 4px; z-index: 10; }
        .graph-controls button { width: 32px; height: 32px; border: 1px solid #0f3460; background: #16213e; color: #e0e0e0; font-size: 18px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .graph-controls button:hover { background: #0f3460; }
        .graph-filters { display: flex; align-items: center; gap: 0.8rem; flex-wrap: wrap; margin: 0.5rem 0; padding: 0.5rem 0.8rem; background: #16213e; border-radius: 6px; border: 1px solid #0f3460; }
        .filter-toggle { display: inline-flex; align-items: center; gap: 0.3rem; cursor: pointer; padding: 0.25rem 0.6rem; border-radius: 4px; border: 1px solid var(--clr); color: var(--clr); font-size: 0.85em; user-select: none; transition: all 0.15s; }
        .filter-toggle:has(input:checked) { background: color-mix(in srgb, var(--clr) 20%, transparent); }
        .filter-toggle:has(input:not(:checked)) { opacity: 0.4; border-style: dashed; }
        .filter-toggle input { display: none; }
        .impact-detail { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; padding: 0.8rem; background: #0d0d1a; border-radius: 6px; margin: 0.5rem 0; }
        .impact-detail ul { list-style: none; padding-left: 0.5rem; }
        .impact-detail li { padding: 0.15rem 0; }
        .impact-detail li::before { content: "â†’ "; color: #4fc3f7; }
        """;
}
